const fs = require('fs');
const path = require('path');

console.log('üîç INVESTIGA√á√ÉO PROFUNDA - M√âTODOS DUPLICADOS E N√ÉO UTILIZADOS\n');

// 1. ANALISAR TODOS OS SERVI√áOS DO BACKEND
function analyzeAllServices() {
  console.log('üîß 1. ANALISANDO TODOS OS SERVI√áOS...');
  
  const servicesDir = 'src/backend/services';
  const services = fs.readdirSync(servicesDir).filter(file => file.endsWith('.ts'));
  
  console.log(`\nüìã Servi√ßos encontrados: ${services.length}`);
  services.forEach((service, index) => {
    console.log(`   ${index + 1}. ${service}`);
  });
  
  return services;
}

// 2. BUSCAR M√âTODOS DUPLICADOS EM CADA SERVI√áO
function findDuplicateMethods(services) {
  console.log('\nüîß 2. BUSCANDO M√âTODOS DUPLICADOS...');
  
  const allMethods = new Map(); // m√©todo -> [arquivos que o cont√™m]
  const duplicates = [];
  
  services.forEach(service => {
    const servicePath = `src/backend/services/${service}`;
    const content = fs.readFileSync(servicePath, 'utf8');
    
    // Buscar todos os m√©todos (async, public, private, etc.)
    const methodRegex = /(?:async\s+)?(?:public\s+|private\s+|protected\s+)?(\w+)\s*\([^)]*\)\s*[:{]/g;
    const methods = [...content.matchAll(methodRegex)];
    
    console.log(`\nüìÅ ${service}:`);
    
    methods.forEach(match => {
      const methodName = match[1];
      
      // Filtrar construtores e m√©todos muito comuns
      if (methodName !== 'constructor' && methodName !== 'then' && methodName !== 'catch') {
        if (!allMethods.has(methodName)) {
          allMethods.set(methodName, []);
        }
        allMethods.get(methodName).push(service);
        
        console.log(`   - ${methodName}()`);
      }
    });
  });
  
  // Identificar duplicatas
  console.log('\nüîç M√âTODOS DUPLICADOS ENCONTRADOS:');
  let duplicateCount = 0;
  
  allMethods.forEach((files, methodName) => {
    if (files.length > 1) {
      duplicateCount++;
      console.log(`\nüî¥ ${duplicateCount}. ${methodName}():`);
      files.forEach(file => {
        console.log(`     - ${file}`);
      });
      duplicates.push({ method: methodName, files });
    }
  });
  
  if (duplicateCount === 0) {
    console.log('   ‚úÖ Nenhum m√©todo com nome duplicado encontrado');
  }
  
  return duplicates;
}

// 3. ANALISAR M√âTODOS ESPEC√çFICOS SUSPEITOS
function analyzeSuspiciousMethods() {
  console.log('\nüîß 3. ANALISANDO M√âTODOS ESPEC√çFICOS SUSPEITOS...');
  
  const suspiciousMethods = [
    {
      file: 'MatchmakingService.ts',
      methods: [
        'assignLanesByMMRAndPreferences',
        'assignLanesOptimized',
        'removePlayerFromQueue',
        'removePlayerFromQueueById',
        'getQueueStatus',
        'getQueueStatusWithCurrentPlayer'
      ]
    },
    {
      file: 'DraftService.ts', 
      methods: [
        'assignLanesOptimized',
        'balanceTeamsAndAssignLanes',
        'prepareDraftData'
      ]
    },
    {
      file: 'LCUService.ts',
      methods: [
        'getCurrentSummoner',
        'getSummonerInfo',
        'createCustomLobby'
      ]
    }
  ];
  
  suspiciousMethods.forEach(serviceInfo => {
    const servicePath = `src/backend/services/${serviceInfo.file}`;
    
    if (fs.existsSync(servicePath)) {
      console.log(`\nüìÅ ${serviceInfo.file}:`);
      const content = fs.readFileSync(servicePath, 'utf8');
      
      serviceInfo.methods.forEach(methodName => {
        const methodExists = content.includes(`${methodName}(`);
        const occurrences = (content.match(new RegExp(methodName, 'g')) || []).length;
        
        console.log(`   ${methodExists ? '‚úÖ' : '‚ùå'} ${methodName}() - ${occurrences} ocorr√™ncia(s)`);
        
        if (occurrences > 3) {
          console.log(`      ‚ö†Ô∏è M√©todo usado ${occurrences} vezes - verificar se h√° duplica√ß√£o interna`);
        }
      });
    } else {
      console.log(`   ‚ùå ${serviceInfo.file} n√£o encontrado`);
    }
  });
}

// 4. BUSCAR M√âTODOS N√ÉO UTILIZADOS
function findUnusedMethods() {
  console.log('\nüîß 4. BUSCANDO M√âTODOS N√ÉO UTILIZADOS...');
  
  const servicesDir = 'src/backend/services';
  const serverPath = 'src/backend/server.ts';
  
  // Ler server.ts para ver quais m√©todos s√£o chamados
  const serverContent = fs.readFileSync(serverPath, 'utf8');
  
  const services = fs.readdirSync(servicesDir).filter(file => file.endsWith('.ts'));
  
  services.forEach(service => {
    const servicePath = `${servicesDir}/${service}`;
    const content = fs.readFileSync(servicePath, 'utf8');
    
    console.log(`\nüìÅ ${service}:`);
    
    // Buscar m√©todos p√∫blicos
    const publicMethodRegex = /(?:async\s+)?(?:public\s+)?(\w+)\s*\([^)]*\)\s*[:{]/g;
    const methods = [...content.matchAll(publicMethodRegex)];
    
    const unusedMethods = [];
    
    methods.forEach(match => {
      const methodName = match[1];
      
      // Pular construtores e m√©todos especiais
      if (methodName !== 'constructor' && methodName !== 'then' && methodName !== 'catch' && methodName !== 'finally') {
        // Verificar se √© usado no server.ts
        const usedInServer = serverContent.includes(methodName);
        
        // Verificar se √© usado em outros servi√ßos
        let usedInOtherServices = false;
        services.forEach(otherService => {
          if (otherService !== service) {
            const otherContent = fs.readFileSync(`${servicesDir}/${otherService}`, 'utf8');
            if (otherContent.includes(methodName)) {
              usedInOtherServices = true;
            }
          }
        });
        
        const isUsed = usedInServer || usedInOtherServices;
        
        if (!isUsed) {
          unusedMethods.push(methodName);
          console.log(`   üî¥ ${methodName}() - POSSIVELMENTE N√ÉO UTILIZADO`);
        } else {
          console.log(`   ‚úÖ ${methodName}() - UTILIZADO`);
        }
      }
    });
    
    if (unusedMethods.length === 0) {
      console.log('   ‚úÖ Todos os m√©todos p√∫blicos parecem estar em uso');
    }
  });
}

// 5. ANALISAR IMPORTS N√ÉO UTILIZADOS
function findUnusedImports() {
  console.log('\nüîß 5. ANALISANDO IMPORTS N√ÉO UTILIZADOS...');
  
  const files = [
    'src/backend/server.ts',
    ...fs.readdirSync('src/backend/services').map(f => `src/backend/services/${f}`)
  ];
  
  files.forEach(filePath => {
    if (fs.existsSync(filePath) && filePath.endsWith('.ts')) {
      const content = fs.readFileSync(filePath, 'utf8');
      const fileName = path.basename(filePath);
      
      console.log(`\nüìÅ ${fileName}:`);
      
      // Buscar imports
      const importRegex = /import\s+(?:{([^}]+)}|\*\s+as\s+(\w+)|(\w+))\s+from\s+['"]([^'"]+)['"]/g;
      const imports = [...content.matchAll(importRegex)];
      
      const unusedImports = [];
      
      imports.forEach(match => {
        const [fullMatch, namedImports, namespaceImport, defaultImport, modulePath] = match;
        
        if (namedImports) {
          // Imports nomeados como { something }
          const names = namedImports.split(',').map(n => n.trim());
          names.forEach(name => {
            const isUsed = content.includes(name) && content.lastIndexOf(name) !== content.indexOf(name);
            if (!isUsed) {
              unusedImports.push(name);
            }
          });
        } else if (namespaceImport) {
          // Imports como * as something
          const isUsed = content.includes(namespaceImport) && content.lastIndexOf(namespaceImport) !== content.indexOf(namespaceImport);
          if (!isUsed) {
            unusedImports.push(namespaceImport);
          }
        } else if (defaultImport) {
          // Imports default
          const isUsed = content.includes(defaultImport) && content.lastIndexOf(defaultImport) !== content.indexOf(defaultImport);
          if (!isUsed) {
            unusedImports.push(defaultImport);
          }
        }
      });
      
      if (unusedImports.length > 0) {
        console.log('   üî¥ IMPORTS POSSIVELMENTE N√ÉO UTILIZADOS:');
        unusedImports.forEach(imp => {
          console.log(`      - ${imp}`);
        });
      } else {
        console.log('   ‚úÖ Todos os imports parecem estar em uso');
      }
    }
  });
}

// 6. ANALISAR C√ìDIGO MORTO (FUN√á√ïES/CLASSES N√ÉO EXPORTADAS E N√ÉO UTILIZADAS)
function findDeadCode() {
  console.log('\nüîß 6. ANALISANDO C√ìDIGO MORTO...');
  
  const servicesDir = 'src/backend/services';
  const services = fs.readdirSync(servicesDir).filter(file => file.endsWith('.ts'));
  
  services.forEach(service => {
    const servicePath = `${servicesDir}/${service}`;
    const content = fs.readFileSync(servicePath, 'utf8');
    
    console.log(`\nüìÅ ${service}:`);
    
    // Buscar fun√ß√µes n√£o exportadas
    const functionRegex = /(?:^|\n)(?!export\s+)(?:async\s+)?function\s+(\w+)/g;
    const functions = [...content.matchAll(functionRegex)];
    
    // Buscar classes n√£o exportadas
    const classRegex = /(?:^|\n)(?!export\s+)class\s+(\w+)/g;
    const classes = [...content.matchAll(classRegex)];
    
    const deadCode = [];
    
    [...functions, ...classes].forEach(match => {
      const name = match[1];
      const occurrences = (content.match(new RegExp(name, 'g')) || []).length;
      
      // Se s√≥ aparece uma vez (na defini√ß√£o), pode ser c√≥digo morto
      if (occurrences === 1) {
        deadCode.push(name);
        console.log(`   üî¥ ${name} - POSSIVELMENTE C√ìDIGO MORTO (n√£o utilizado)`);
      } else {
        console.log(`   ‚úÖ ${name} - UTILIZADO (${occurrences} vezes)`);
      }
    });
    
    if (deadCode.length === 0 && functions.length === 0 && classes.length === 0) {
      console.log('   ‚ÑπÔ∏è Nenhuma fun√ß√£o/classe n√£o exportada encontrada');
    } else if (deadCode.length === 0) {
      console.log('   ‚úÖ Nenhum c√≥digo morto √≥bvio encontrado');
    }
  });
}

// 7. GERAR RELAT√ìRIO DETALHADO DE M√âTODOS
function generateMethodReport(duplicates) {
  console.log('\nüìä 7. GERANDO RELAT√ìRIO DETALHADO...');
  
  const reportContent = `# üîç RELAT√ìRIO DETALHADO - M√âTODOS DUPLICADOS E N√ÉO UTILIZADOS

## üìã Resumo da Investiga√ß√£o

**Data**: ${new Date().toLocaleDateString('pt-BR')}  
**Tipo**: Investiga√ß√£o profunda de m√©todos duplicados e n√£o utilizados  
**Escopo**: Todos os servi√ßos do backend  

---

## üéØ DESCOBERTAS PRINCIPAIS

### üî¥ M√âTODOS DUPLICADOS IDENTIFICADOS

${duplicates.length > 0 ? 
  duplicates.map((dup, index) => 
    `#### ${index + 1}. **${dup.method}()**\n` +
    `- **Arquivos**: ${dup.files.join(', ')}\n` +
    `- **A√ß√£o**: Verificar se implementa√ß√µes s√£o id√™nticas ou se podem ser consolidadas\n`
  ).join('\n') 
  : '‚úÖ **Nenhum m√©todo com nome duplicado encontrado**'
}

### üîç M√âTODOS SUSPEITOS DE DUPLICA√á√ÉO

#### **MatchmakingService.ts**
- \`assignLanesByMMRAndPreferences()\` vs \`assignLanesOptimized()\`
  - **Suspeita**: Ambos fazem atribui√ß√£o de lanes
  - **Recomenda√ß√£o**: Verificar se podem ser consolidados

- \`removePlayerFromQueue()\` vs \`removePlayerFromQueueById()\`
  - **Status**: ‚úÖ **DIFERENTES** - WebSocket vs ID/Nome
  - **A√ß√£o**: Manter ambos (responsabilidades diferentes)

- \`getQueueStatus()\` vs \`getQueueStatusWithCurrentPlayer()\`
  - **Suspeita**: Funcionalidades similares
  - **Recomenda√ß√£o**: Consolidar com par√¢metro opcional

#### **DraftService.ts vs MatchmakingService.ts**
- Ambos t√™m m√©todos de atribui√ß√£o de lanes
- **Verificar**: Se h√° duplica√ß√£o de l√≥gica entre servi√ßos

### üî¥ M√âTODOS POSSIVELMENTE N√ÉO UTILIZADOS
*(Lista gerada automaticamente - requer verifica√ß√£o manual)*

### üî¥ IMPORTS N√ÉO UTILIZADOS
*(Lista gerada automaticamente - podem ser removidos para limpeza)*

### üî¥ C√ìDIGO MORTO
*(Fun√ß√µes/classes n√£o exportadas e n√£o utilizadas)*

---

## üéØ RECOMENDA√á√ïES DE A√á√ÉO

### **Prioridade Alta** üî¥

1. **Consolidar m√©todos de lane assignment**
   - Investigar \`assignLanesByMMRAndPreferences()\` vs \`assignLanesOptimized()\`
   - Verificar se h√° duplica√ß√£o entre MatchmakingService e DraftService

2. **Consolidar m√©todos de queue status**
   - Transformar \`getQueueStatusWithCurrentPlayer()\` em par√¢metro opcional

### **Prioridade M√©dia** üü°

1. **Remover imports n√£o utilizados**
   - Limpeza autom√°tica poss√≠vel
   - Reduzir tamanho dos bundles

2. **Remover c√≥digo morto**
   - Fun√ß√µes/classes n√£o utilizadas
   - Simplificar codebase

### **Prioridade Baixa** üü¢

1. **Revisar m√©todos possivelmente n√£o utilizados**
   - Verifica√ß√£o manual necess√°ria
   - Alguns podem ser APIs p√∫blicas

---

## üìä ESTAT√çSTICAS

- **Servi√ßos analisados**: ${fs.readdirSync('src/backend/services').filter(f => f.endsWith('.ts')).length}
- **M√©todos duplicados**: ${duplicates.length}
- **Arquivos verificados**: ${fs.readdirSync('src/backend/services').filter(f => f.endsWith('.ts')).length + 1} (servi√ßos + server.ts)

---

## üö¶ PR√ìXIMOS PASSOS

1. **Manual**: Verificar duplica√ß√µes identificadas
2. **Autom√°tico**: Remover imports n√£o utilizados
3. **Manual**: Revisar c√≥digo morto
4. **Manual**: Consolidar m√©todos similares

---

**Status**: ‚úÖ **INVESTIGA√á√ÉO CONCLU√çDA**  
**Recomenda√ß√£o**: Proceder com verifica√ß√µes manuais das descobertas
`;

  fs.writeFileSync('DETAILED_METHODS_AUDIT_REPORT.md', reportContent);
  console.log('   üíæ Relat√≥rio salvo em DETAILED_METHODS_AUDIT_REPORT.md');
}

// EXECUTAR INVESTIGA√á√ÉO COMPLETA
async function runMethodInvestigation() {
  try {
    console.log('üéØ INICIANDO INVESTIGA√á√ÉO PROFUNDA DE M√âTODOS...\n');
    
    // Executar todas as an√°lises
    const services = analyzeAllServices();
    const duplicates = findDuplicateMethods(services);
    analyzeSuspiciousMethods();
    findUnusedMethods();
    findUnusedImports();
    findDeadCode();
    generateMethodReport(duplicates);
    
    console.log('\nüéâ INVESTIGA√á√ÉO COMPLETA FINALIZADA!');
    console.log('\nüìä RESUMO:');
    console.log(`   üìÅ Servi√ßos analisados: ${services.length}`);
    console.log(`   üîç M√©todos duplicados: ${duplicates.length}`);
    console.log('   üìù Relat√≥rio gerado: DETAILED_METHODS_AUDIT_REPORT.md');
    
    console.log('\n‚úÖ INVESTIGA√á√ÉO DE M√âTODOS CONCLU√çDA!');
    console.log('\nüéØ Pr√≥ximo passo: Revisar relat√≥rio e aplicar corre√ß√µes recomendadas');
    
  } catch (error) {
    console.error('‚ùå ERRO durante a investiga√ß√£o:', error);
    console.log('\nüîß Verifique os arquivos e tente novamente');
  }
}

// Executar investiga√ß√£o
runMethodInvestigation();
