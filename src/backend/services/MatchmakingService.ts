import { DatabaseManager } from '../database/DatabaseManager';
import { WebSocket } from 'ws';

// Interfaces
interface QueuedPlayer {
  id: number;
  summonerName: string;
  region: string;
  currentMMR: number;
  joinTime: Date;
  websocket: WebSocket;
  queuePosition?: number;
  preferences?: {
    primaryLane?: string;
    secondaryLane?: string;
    autoAccept?: boolean;
    assignedLane?: string;
    isAutofill?: boolean;
  };
}

interface Match {
  id: number;
  team1: QueuedPlayer[];
  team2: QueuedPlayer[];
  createdAt: Date;
  status: 'waiting' | 'in_progress' | 'completed' | 'waiting_accept';
  averageMMR1: number;
  averageMMR2: number;
  acceptedPlayers: Set<number>; // IDs dos jogadores que aceitaram
  acceptTimeout?: NodeJS.Timeout; // Timer para timeout da aceita√ß√£o
}

interface QueueStatus {
  playersInQueue: number;
  averageWaitTime: number;
  estimatedMatchTime: number;
  isActive: boolean;
  playersInQueueList?: QueuedPlayerInfo[];
  recentActivities?: QueueActivity[];
}

interface QueuedPlayerInfo {
  summonerName: string;
  tagLine?: string;
  primaryLane: string;
  secondaryLane: string;
  primaryLaneDisplay: string;
  secondaryLaneDisplay: string;
  mmr: number;
  queuePosition: number;
  joinTime: Date;
}

interface QueueActivity {
  id: string;
  timestamp: Date;
  type: 'player_joined' | 'player_left' | 'match_created' | 'system_update' | 'queue_cleared';
  message: string;
  playerName?: string;
  playerTag?: string;
  lane?: string;
}

export class MatchmakingService {
  private dbManager: DatabaseManager;
  private wss: any; // WebSocketServer
  private queue: QueuedPlayer[] = [];
  private activeMatches: Map<number, Match> = new Map();
  private matchmakingInterval: NodeJS.Timeout | null = null;
  private cleanupInterval: NodeJS.Timeout | null = null; // Novo: intervalo de limpeza
  private isActive = true;
  private recentActivities: QueueActivity[] = [];
  private readonly MAX_ACTIVITIES = 20;
  private readonly QUEUE_TIMEOUT_MINUTES = 120; // Timeout para jogadores inativos (2 horas)
  private readonly CLEANUP_INTERVAL_MS = 30000; // Limpeza a cada 30 segundos
  private nextMatchId = 1; // Adicionar propriedade nextMatchId

  // Otimiza√ß√µes de performance - REMOVIDO DEBOUNCE DESNECESS√ÅRIO
  // Broadcast imediato apenas quando necess√°rio (entrada/sa√≠da da fila)
  private lastBroadcastTime = 0;
  private readonly MIN_BROADCAST_INTERVAL = 100; // M√≠nimo 100ms entre broadcasts para evitar spam

  // NOVO: Sistema de sincroniza√ß√£o via MySQL
  private syncInterval: NodeJS.Timeout | null = null;
  private readonly SYNC_INTERVAL_MS = 2000; // Sincronizar a cada 2 segundos
  private lastSyncTime = 0;

  constructor(dbManager: DatabaseManager, wss?: any) {
    this.dbManager = dbManager;
    this.wss = wss;
    console.log('üéØ MatchmakingService inicializado');
  }

  async initialize(): Promise<void> {
    console.log('üöÄ Inicializando MatchmakingService...');

    // Carregar fila do banco de dados
    await this.loadQueueFromDatabase();

    // Iniciar intervalos
    this.startMatchmakingInterval();
    this.startCleanupInterval();
    
    // NOVO: Iniciar sincroniza√ß√£o via MySQL
    this.startMySQLSync();

    console.log('‚úÖ MatchmakingService inicializado com sucesso');
  }

  // NOVO: Iniciar sincroniza√ß√£o via MySQL
  private startMySQLSync(): void {
    console.log('‚ö†Ô∏è [MySQL Sync] Sincroniza√ß√£o autom√°tica DESABILITADA para preservar dados');
    console.log('üîß [MySQL Sync] Sincroniza√ß√£o ser√° executada apenas sob demanda (refreshs manuais)');
    
    // ‚úÖ DESABILITADO: Sincroniza√ß√£o autom√°tica a cada 2 segundos
    // Motivo: Prevenir sobrescrita de custom_lp e lanes originais
    /*
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }

    this.syncInterval = setInterval(async () => {
      try {
        await this.syncQueueWithDatabase();
      } catch (error) {
        console.error('‚ùå [MySQL Sync] Erro na sincroniza√ß√£o:', error);
      }
    }, this.SYNC_INTERVAL_MS);

    console.log(`üîÑ [MySQL Sync] Sincroniza√ß√£o iniciada a cada ${this.SYNC_INTERVAL_MS}ms`);
    */
  }

  // ‚úÖ CORRE√á√ÉO: Sincronizar fila com banco de dados (APENAS LEITURA)
  private async syncQueueWithDatabase(): Promise<void> {
    try {
      const currentTime = Date.now();
      if (currentTime - this.lastSyncTime < this.SYNC_INTERVAL_MS) {
        return; // Evitar sincroniza√ß√£o muito frequente
      }
      this.lastSyncTime = currentTime;

      console.log('üîÑ [MySQL Sync] Iniciando sincroniza√ß√£o READ-ONLY da fila com MySQL...');

      // Buscar estado atual da fila no MySQL
      const dbPlayers = await this.dbManager.getActiveQueuePlayers();
      console.log(`üìä [MySQL Sync] Encontrados ${dbPlayers.length} jogadores no MySQL`);
      console.log(`üìä [MySQL Sync] Fila local atual: ${this.queue.length} jogadores`);

      if (dbPlayers.length === 0 && this.queue.length === 0) {
        console.log('‚úÖ [MySQL Sync] Fila vazia em ambos os sistemas - nada para sincronizar');
        return;
      }

      // Criar set de identificadores √∫nicos para cada sistema
      const dbPlayerIds = new Set(dbPlayers.map(p => p.summoner_name));
      const localPlayerIds = new Set(this.queue.map(p => p.summonerName));

      console.log('üîç [MySQL Sync] Jogadores no MySQL:', Array.from(dbPlayerIds));
      console.log('üîç [MySQL Sync] Jogadores na fila local:', Array.from(localPlayerIds));

      // 1. ‚úÖ APENAS REMOVER da fila local jogadores que n√£o est√£o no MySQL
      const playersToRemoveFromLocal = this.queue.filter(localPlayer => 
        !dbPlayerIds.has(localPlayer.summonerName)
      );

      for (const player of playersToRemoveFromLocal) {
        console.log(`‚ûñ [MySQL Sync] Removendo ${player.summonerName} da fila local (n√£o est√° no MySQL)`);
        const index = this.queue.findIndex(p => p.summonerName === player.summonerName);
        if (index !== -1) {
          this.queue.splice(index, 1);
        }
      }

      // 2. ‚úÖ APENAS ADICIONAR jogadores que est√£o no MySQL mas n√£o na fila local
      // IMPORTANTE: Usar dados do MySQL SEM sobrescrever dados j√° existentes
      const playersToAddToLocal = dbPlayers.filter(dbPlayer => 
        !localPlayerIds.has(dbPlayer.summoner_name)
      );

      for (const dbPlayer of playersToAddToLocal) {
        console.log(`‚ûï [MySQL Sync] Adicionando ${dbPlayer.summoner_name} √† fila local (preservando dados originais do MySQL)`);
        
        // ‚úÖ CORRE√á√ÉO: Usar dados DIRETAMENTE do MySQL (queue_players) 
        // sem buscar na tabela players para n√£o sobrescrever
        const queuedPlayer: QueuedPlayer = {
          id: dbPlayer.player_id,
          summonerName: dbPlayer.summoner_name,
          region: dbPlayer.region || 'br1', // Usar regi√£o do MySQL queue_players
          currentMMR: dbPlayer.custom_lp, // ‚úÖ USAR exatamente o custom_lp da entrada na fila
          joinTime: new Date(dbPlayer.join_time),
          websocket: null as any, // Jogador via HTTP/LCU n√£o tem WebSocket
          queuePosition: dbPlayer.queue_position,
          preferences: {
            // ‚úÖ USAR exatamente as lanes da entrada na fila
            primaryLane: dbPlayer.primary_lane,
            secondaryLane: dbPlayer.secondary_lane
          }
        };
        
        this.queue.push(queuedPlayer);
        console.log(`‚úÖ [MySQL Sync] ${dbPlayer.summoner_name} adicionado com dados originais: MMR=${dbPlayer.custom_lp}, Lanes=${dbPlayer.primary_lane}/${dbPlayer.secondary_lane}`);
      }

      // 3. ‚úÖ APENAS ATUALIZAR posi√ß√µes (sem tocar em outros dados)
      for (const dbPlayer of dbPlayers) {
        const localPlayer = this.queue.find(p => p.summonerName === dbPlayer.summoner_name);
        if (localPlayer && localPlayer.queuePosition !== dbPlayer.queue_position) {
          console.log(`üîÑ [MySQL Sync] Atualizando APENAS posi√ß√£o de ${dbPlayer.summoner_name}: ${localPlayer.queuePosition} ‚Üí ${dbPlayer.queue_position}`);
          localPlayer.queuePosition = dbPlayer.queue_position;
          // ‚úÖ N√ÉO tocar em currentMMR, lanes, ou outros dados
        }
      }

      // 4. ORDENAR fila local pela posi√ß√£o
      this.queue.sort((a, b) => (a.queuePosition || 0) - (b.queuePosition || 0));

      // 5. VERIFICAR e CORRIGIR inconsist√™ncias (apenas duplicatas)
      if (this.queue.length !== dbPlayers.length) {
        console.log(`‚ö†Ô∏è [MySQL Sync] Inconsist√™ncia detectada: Local=${this.queue.length}, MySQL=${dbPlayers.length}`);
        
        // Limpar apenas jogadores duplicados (sem modificar dados)
        const seenNames = new Set<string>();
        this.queue = this.queue.filter(player => {
          if (seenNames.has(player.summonerName)) {
            console.log(`üóëÔ∏è [MySQL Sync] Removendo jogador duplicado: ${player.summonerName}`);
            return false;
          }
          seenNames.add(player.summonerName);
          return true;
        });
      }

      console.log(`‚úÖ [MySQL Sync] Sincroniza√ß√£o READ-ONLY conclu√≠da: ${this.queue.length} jogadores na fila`);
      console.log('üìä [MySQL Sync] Fila final (dados preservados):', this.queue.map(p => ({
        name: p.summonerName,
        position: p.queuePosition,
        mmr: p.currentMMR, // ‚úÖ MMR original preservado
        lanes: `${p.preferences?.primaryLane}/${p.preferences?.secondaryLane}`, // ‚úÖ Lanes originais preservadas
        hasWebSocket: !!p.websocket
      })));

      // Broadcast atualiza√ß√£o APENAS se houve mudan√ßas na composi√ß√£o da fila
      if (playersToRemoveFromLocal.length > 0 || playersToAddToLocal.length > 0) {
        await this.broadcastQueueUpdate();
      }

    } catch (error) {
      console.error('‚ùå [MySQL Sync] Erro na sincroniza√ß√£o READ-ONLY:', error);
    }
  }

  // Novo m√©todo: Limpeza autom√°tica de jogadores inativos
  private async cleanupInactivePlayers(): Promise<void> {
    try {
      const now = new Date();
      const timeoutMs = this.QUEUE_TIMEOUT_MINUTES * 60 * 1000;
      const playersToRemove: QueuedPlayer[] = [];

      console.log(`üîç Verificando ${this.queue.length} jogadores na fila para limpeza...`);

      // Verificar jogadores inativos
      for (const player of this.queue) {
        const timeInQueue = now.getTime() - player.joinTime.getTime();
        const timeInQueueMinutes = Math.floor(timeInQueue / (1000 * 60));

        // Verificar se √© um bot (ID negativo)
        const isBot = player.id < 0;

        // ‚úÖ CORRE√á√ÉO: Verificar se WebSocket est√° morto APENAS se existir
        // Se websocket √© null, assume que o jogador foi adicionado via HTTP e deve permanecer na fila
        const hasWebSocket = !!player.websocket;
        const isWebSocketDead = hasWebSocket && (
          player.websocket.readyState === WebSocket.CLOSED ||
          player.websocket.readyState === WebSocket.CLOSING
        );

        // Log do estado do jogador
        console.log(`üë§ ${player.summonerName}: ${timeInQueueMinutes}min na fila, WebSocket: ${hasWebSocket ? (isWebSocketDead ? 'morto' : 'ativo') : 'HTTP/null'}, Bot: ${isBot}`);

        // Para bots: s√≥ remover se tempo for negativo (dados corrompidos) ou timeout muito longo (mais de 24 horas)
        if (isBot) {
          if (timeInQueue < 0 || timeInQueue > (24 * 60 * 60 * 1000)) {
            let reason = timeInQueue < 0 ? 'Dados de tempo corrompidos' : 'Timeout de 24 horas';
            console.log(`‚ö†Ô∏è Marcando bot ${player.summonerName} para remo√ß√£o: ${reason}`);
            playersToRemove.push(player);
          }
          continue; // Pular verifica√ß√µes de WebSocket para bots
        }

        // ‚úÖ CORRE√á√ÉO: Para jogadores reais, s√≥ remover se:
        // 1. TEM WebSocket E est√° morto (jogador desconectou) OU
        // 2. Jogador est√° na fila h√° mais tempo que o timeout (2 horas) OU
        // 3. Tempo negativo (dados corrompidos)
        // 
        // N√ÉO remover jogadores que:
        // - N√£o t√™m WebSocket (foram adicionados via HTTP/LCU)
        // - T√™m WebSocket ativo
        const shouldRemove = 
          (hasWebSocket && isWebSocketDead) ||  // WebSocket morto
          timeInQueue > timeoutMs ||            // Timeout muito longo
          timeInQueue < 0;                      // Dados corrompidos

        if (shouldRemove) {
          let reason = '';
          if (timeInQueue < 0) {
            reason = 'Dados de tempo corrompidos';
          } else if (hasWebSocket && isWebSocketDead) {
            reason = 'WebSocket desconectado';
          } else if (timeInQueue > timeoutMs) {
            reason = 'Timeout de 2 horas';
          }
          console.log(`‚ö†Ô∏è Marcando ${player.summonerName} para remo√ß√£o: ${reason}`);
          playersToRemove.push(player);
        } else if (!hasWebSocket) {
          console.log(`‚úÖ ${player.summonerName} mantido na fila (sem WebSocket - provavelmente via HTTP/LCU)`);
        }
      }

      // Remover jogadores inativos
      for (const player of playersToRemove) {
        const playerIndex = this.queue.findIndex(p => p.id === player.id);
        if (playerIndex !== -1) {
          this.queue.splice(playerIndex, 1);

          // ‚úÖ CORRE√á√ÉO: Persistir sa√≠da da fila no banco APENAS para jogadores reais
          if (player.id > 0) {
            console.log(`üóëÔ∏è Removendo ${player.summonerName} do MySQL (is_active = 0)`);
            await this.dbManager.removePlayerFromQueue(player.id);
          }

          // Adicionar atividade de sa√≠da autom√°tica
          this.addActivity(
            'player_left',
            `${player.summonerName} removido automaticamente da fila (inativo)`,
            player.summonerName
          );
        }
      }

      // Atualizar posi√ß√µes se houve remo√ß√µes
      if (playersToRemove.length > 0) {
        console.log(`üîÑ ${playersToRemove.length} jogadores removidos, atualizando posi√ß√µes...`);
        await this.updateQueuePositions();
        await this.broadcastQueueUpdate();
      }

    } catch (error) {
      console.error('Erro na limpeza de jogadores inativos:', error);
    }
  }

  // M√©todo para verificar se um WebSocket est√° ativo
  private isWebSocketActive(websocket: WebSocket): boolean {
    return websocket &&
      websocket.readyState === WebSocket.OPEN;
  }

  // M√©todo para carregar fila do banco de dados
  private async loadQueueFromDatabase(): Promise<void> {
    try {
      console.log('üìä [Matchmaking] Carregando fila do banco de dados...');
      
      const queuePlayers = await this.dbManager.getActiveQueuePlayers();
      console.log(`üìä [Matchmaking] Encontrados ${queuePlayers.length} jogadores ativos no banco`);

      for (const dbPlayer of queuePlayers) {
        // Validar dados de tempo
        const joinTime = new Date(dbPlayer.join_time);
        const now = new Date();
        const timeInQueue = now.getTime() - joinTime.getTime();
        const timeInQueueMinutes = Math.floor(timeInQueue / (1000 * 60));

        // Se o tempo for negativo (dados corrompidos), pular este jogador
        if (timeInQueue < 0) {
          console.log(`‚ö†Ô∏è [Matchmaking] Jogador com dados de tempo corrompidos: ${dbPlayer.summoner_name}`);
          console.log(`   - join_time: ${dbPlayer.join_time}`);
          console.log(`   - timeInQueue: ${timeInQueueMinutes}min`);
          console.log(`   - Removendo da fila persistente...`);

          // Remover da fila persistente
          try {
            await this.dbManager.removePlayerFromQueue(dbPlayer.player_id);
            console.log(`‚úÖ [Matchmaking] Jogador removido da fila persistente: ${dbPlayer.summoner_name}`);
          } catch (error) {
            console.error(`‚ùå [Matchmaking] Erro ao remover jogador da fila persistente:`, error);
          }
          continue;
        }

        // Para jogadores muito antigos (mais de 6 horas), remover automaticamente
        if (timeInQueue > (6 * 60 * 60 * 1000)) {
          console.log(`‚ö†Ô∏è [Matchmaking] Jogador muito antigo na fila: ${dbPlayer.summoner_name} (${timeInQueueMinutes}min)`);
          console.log(`   - Removendo automaticamente...`);

          try {
            await this.dbManager.removePlayerFromQueue(dbPlayer.player_id);
            console.log(`‚úÖ [Matchmaking] Jogador antigo removido: ${dbPlayer.summoner_name}`);
          } catch (error) {
            console.error(`‚ùå [Matchmaking] Erro ao remover jogador antigo:`, error);
          }
          continue;
        }

        // Verificar se o jogador j√° est√° na fila local (evitar duplicatas)
        const existingPlayer = this.queue.find(p => p.id === dbPlayer.player_id);
        if (existingPlayer) {
          console.log(`üîÑ [Matchmaking] Jogador j√° carregado na fila local: ${dbPlayer.summoner_name}`);
          continue;
        }

        const queuedPlayer: QueuedPlayer = {
          id: dbPlayer.player_id,
          summonerName: dbPlayer.summoner_name,
          region: dbPlayer.region,
          currentMMR: dbPlayer.custom_lp || 0,
          joinTime: joinTime,
          websocket: null as any, // WebSocket ser√° atualizado quando o jogador reconectar
          queuePosition: dbPlayer.queue_position || 0,
          preferences: {
            primaryLane: dbPlayer.primary_lane || 'fill',
            secondaryLane: dbPlayer.secondary_lane || 'fill'
          }
        };

        this.queue.push(queuedPlayer);
        console.log(`üìä [Matchmaking] Jogador carregado da fila persistente: ${dbPlayer.summoner_name} (${timeInQueueMinutes}min na fila, posi√ß√£o: ${queuedPlayer.queuePosition})`);
      }

      // Garantir que as posi√ß√µes estejam corretas ap√≥s carregar
      await this.updateQueuePositions();

      console.log(`üìä [Matchmaking] Carregados ${this.queue.length} jogadores da fila persistente`);
      
      // Adicionar atividades iniciais
      this.addActivity('system_update', 'Sistema de matchmaking inicializado');
      this.addActivity('system_update', `Fila carregada com ${this.queue.length} jogadores`);
    } catch (error) {
      console.error('‚ùå [Matchmaking] Erro ao carregar fila do banco:', error);
    }
  }

  async addPlayerToQueue(websocket: WebSocket, playerData: any, preferences?: any): Promise<void> {
    try {
      console.log('‚ûï [Matchmaking] Adicionando jogador √† fila:', playerData);

      // Construir o nome completo no formato gameName#tagLine
      const fullSummonerName = playerData.gameName && playerData.tagLine 
        ? `${playerData.gameName}#${playerData.tagLine}`
        : playerData.summonerName;

      console.log('üîç [Matchmaking] Nome completo do jogador:', fullSummonerName);

      // PRIMEIRO: Verificar se j√° est√° na fila no MySQL
      const existingInDB = await this.dbManager.getActiveQueuePlayers();
      const isAlreadyInQueue = existingInDB.some(dbPlayer => 
        dbPlayer.summoner_name === fullSummonerName ||
        dbPlayer.player_id === playerData.id
      );

      if (isAlreadyInQueue) {
        console.log(`‚ö†Ô∏è [Matchmaking] Jogador ${fullSummonerName} j√° est√° na fila (MySQL)`);
        websocket.send(JSON.stringify({
          type: 'error',
          message: 'Voc√™ j√° est√° na fila'
        }));
        return;
      }

      // SEGUNDO: Verificar se j√° est√° na fila local
      const existingInLocal = this.queue.find(p => 
        p.summonerName === fullSummonerName ||
        p.id === playerData.id
      );

      if (existingInLocal) {
        console.log(`‚ö†Ô∏è [Matchmaking] Jogador ${fullSummonerName} j√° est√° na fila (local)`);
        websocket.send(JSON.stringify({
          type: 'error',
          message: 'Voc√™ j√° est√° na fila'
        }));
        return;
      }

      // TERCEIRO: Adicionar ao MySQL PRIMEIRO
      await this.dbManager.addPlayerToQueue(
        playerData.id,
        fullSummonerName, // Usar nome completo
        playerData.region,
        playerData.customLp || 0,
        preferences
      );

      // QUARTO: Adicionar √† fila local
      const queuedPlayer: QueuedPlayer = {
        id: playerData.id,
        summonerName: fullSummonerName, // Usar nome completo
        region: playerData.region,
        currentMMR: playerData.customLp || 0,
        joinTime: new Date(),
        websocket: websocket,
        queuePosition: this.queue.length + 1,
        preferences: preferences || {
          primaryLane: 'fill',
          secondaryLane: 'fill'
        }
      };

      this.queue.push(queuedPlayer);

      // QUINTO: Atualizar posi√ß√µes no MySQL
      await this.updateQueuePositions();

      // SEXTO: Adicionar atividade
      this.addActivity(
        'player_joined',
        `${fullSummonerName} entrou na fila`,
        fullSummonerName,
        preferences?.primaryLane || 'fill'
      );

      // S√âTIMO: Notificar jogador
      websocket.send(JSON.stringify({
        type: 'queue_joined',
        data: {
          position: queuedPlayer.queuePosition,
          estimatedWait: this.calculateEstimatedWaitTime(),
          queueStatus: this.getQueueStatus()
        }
      }));

      // OITAVO: Broadcast atualiza√ß√£o da fila
      await this.broadcastQueueUpdate();

      console.log(`‚úÖ [Matchmaking] ${fullSummonerName} adicionado √† fila (MySQL + Local)`);

    } catch (error: any) {
      console.error('‚ùå [Matchmaking] Erro ao adicionar jogador √† fila:', error);
      websocket.send(JSON.stringify({
        type: 'error',
        message: 'Falha ao entrar na fila: ' + error.message
      }));
    }
  }

  async removePlayerFromQueue(websocket: WebSocket): Promise<void> {
    console.log('üîç [Matchmaking] removePlayerFromQueue chamado via WebSocket');
    console.log('üîç [Matchmaking] Fila atual:', this.queue.map(p => ({
      id: p.id,
      name: p.summonerName,
      wsActive: p.websocket?.readyState === WebSocket.OPEN,
      wsRef: p.websocket === websocket ? 'MATCH' : 'DIFFERENT'
    })));

    // Tentar encontrar o jogador por WebSocket
    let playerIndex = this.queue.findIndex(player => player.websocket === websocket);
    console.log('üîç [Matchmaking] Player index encontrado por WebSocket:', playerIndex);

    // Se n√£o encontrou por WebSocket, tentar por WebSocket ID ou refer√™ncia
    if (playerIndex === -1) {
      console.log('üîç [Matchmaking] Tentando busca alternativa por WebSocket...');
      console.log('üîç [Matchmaking] WebSocket recebido:', {
        readyState: websocket.readyState,
        url: (websocket as any).url,
        protocol: (websocket as any).protocol
      });

      // Tentar encontrar por qualquer crit√©rio que possa identificar o WebSocket
      playerIndex = this.queue.findIndex(player => {
        const playerWs = player.websocket;
        return playerWs && (
          playerWs === websocket ||
          playerWs.readyState === websocket.readyState ||
          (playerWs as any).url === (websocket as any).url
        );
      });
      console.log('üîç [Matchmaking] Player index encontrado por busca alternativa:', playerIndex);
    }

    console.log('üîç [Matchmaking] Tamanho da fila antes:', this.queue.length);

    if (playerIndex !== -1) {
      const player = this.queue[playerIndex];
      console.log('‚úÖ [Matchmaking] Removendo jogador:', { id: player.id, name: player.summonerName });

      this.queue.splice(playerIndex, 1);

      // Persistir sa√≠da da fila no banco
      this.dbManager.removePlayerFromQueue(player.id).then(() => {
        console.log(`‚úÖ [Matchmaking] Jogador ${player.summonerName} removido da fila persistente`);
      }).catch(error => {
        console.error('‚ùå [Matchmaking] Erro ao remover jogador da fila persistente:', error);
      });

      // Adicionar atividade de sa√≠da
      this.addActivity(
        'player_left',
        `${player.summonerName} saiu da fila`,
        player.summonerName
      );

      // Atualizar posi√ß√µes na fila E NO BANCO
      await this.updateQueuePositions();

      console.log(`‚ûñ [Matchmaking] ${player.summonerName} saiu da fila`);
      console.log('üîç [Matchmaking] Tamanho da fila depois:', this.queue.length);
      console.log('üîç [Matchmaking] Nova fila:', this.queue.map(p => ({ id: p.id, name: p.summonerName })));

      // Broadcast atualiza√ß√£o da fila (for√ßar imediatamente para sa√≠da)
      await this.forceQueueUpdate();
    } else {
      console.log('‚ö†Ô∏è [Matchmaking] Jogador n√£o encontrado na fila para remo√ß√£o via WebSocket');
      console.log('üîç [Matchmaking] WebSocket recebido:', {
        readyState: websocket.readyState,
        url: (websocket as any).url,
        protocol: (websocket as any).protocol
      });
      console.log('üîç [Matchmaking] WebSockets na fila:', this.queue.map(p => ({
        name: p.summonerName,
        wsState: p.websocket?.readyState,
        wsUrl: (p.websocket as any)?.url
      })));
    }
  }

  // NOVO: M√©todo para atualizar posi√ß√µes na fila e no banco
  private async updateQueuePositions(): Promise<void> {
    try {
      // Atualizar posi√ß√µes na mem√≥ria
      this.queue.forEach((p, index) => {
        p.queuePosition = index + 1;
      });

      // Atualizar posi√ß√µes no banco de dados
      for (let i = 0; i < this.queue.length; i++) {
        const player = this.queue[i];
        await this.dbManager.updateQueuePosition(player.id, i + 1);
      }

      console.log(`‚úÖ [Matchmaking] Posi√ß√µes da fila atualizadas: ${this.queue.length} jogadores`);
    } catch (error) {
      console.error('‚ùå [Matchmaking] Erro ao atualizar posi√ß√µes da fila:', error);
    }
  }

  // M√©todo para adicionar jogador √† fila sem WebSocket (para uso autom√°tico)
  addPlayerToQueueDirect(playerData: any): void {
    try {
      // Verificar se o jogador j√° est√° na fila
      const existingPlayer = this.queue.find(p => p.id === playerData.id); if (existingPlayer) {
        // console.log(`‚ö†Ô∏è Jogador ${playerData.summonerName} j√° est√° na fila`);
        return;
      }

      const queuedPlayer: QueuedPlayer = {
        id: playerData.id,
        summonerName: playerData.summonerName,
        region: playerData.region,
        currentMMR: playerData.currentMMR,
        joinTime: new Date(),
        websocket: null as any, // Para entrada autom√°tica, sem WebSocket
        queuePosition: this.queue.length + 1
      };

      this.queue.push(queuedPlayer);
      // Registrar entrada na fila no banco
      this.dbManager.recordQueueAction('join', queuedPlayer.id);

      console.log(`üéØ Jogador ${playerData.summonerName} adicionado √† fila automaticamente (posi√ß√£o ${queuedPlayer.queuePosition})`);

      // Notificar outros jogadores via WebSocket sobre atualiza√ß√£o da fila
      this.broadcastQueueUpdate();
    } catch (error) {
      console.error('Erro ao adicionar jogador √† fila:', error);
    }
  }

  // M√©todo tempor√°rio para adicionar bots na fila (apenas para testes)
  async addBotToQueue(): Promise<void> {
    const availableLanes = ['top', 'jungle', 'mid', 'bot', 'support'];
    const usedLanes = this.queue.map(p => p.preferences?.primaryLane).filter(Boolean);
    const availableUnusedLanes = availableLanes.filter(lane => !usedLanes.includes(lane));

    // Se n√£o h√° lanes livres, usar lane aleat√≥ria mesmo assim
    const selectedLanes = availableUnusedLanes.length > 0 ? availableUnusedLanes : availableLanes;
    const primaryLane = selectedLanes[Math.floor(Math.random() * selectedLanes.length)];

    // Selecionar lane secund√°ria diferente da prim√°ria
    let secondaryLane = availableLanes.filter(lane => lane !== primaryLane)[Math.floor(Math.random() * 4)];

    const botNumber = this.queue.filter(p => p.summonerName.startsWith('Bot')).length + 1;
    const botName = `Bot${botNumber}`;

    // Gerar MMR aleat√≥rio entre 800 e 2000
    const randomMMR = Math.floor(Math.random() * 1200) + 800;

    const botPlayer: QueuedPlayer = {
      id: -botNumber, // ID negativo para distinguir de jogadores reais
      summonerName: botName,
      region: 'br1',
      currentMMR: randomMMR,
      joinTime: new Date(),
      websocket: null as any, // Bots n√£o t√™m WebSocket
      queuePosition: this.queue.length + 1,
      preferences: {
        primaryLane: primaryLane,
        secondaryLane: secondaryLane,
        autoAccept: true
      }
    };

    this.queue.push(botPlayer);

    // Adicionar atividade
    const primaryLaneName = this.getLaneName(primaryLane);
    this.addActivity(
      'player_joined',
      `ü§ñ ${botName} (Bot) entrou na fila como ${primaryLaneName}`,
      botName,
      undefined,
      primaryLane
    );

    console.log(`ü§ñ Bot ${botName} adicionado √† fila - Lane: ${primaryLaneName}, MMR: ${randomMMR}`);

    // Atualizar posi√ß√µes na fila
    this.queue.forEach((p, index) => {
      p.queuePosition = index + 1;
    });

    // Notificar todos os clientes sobre a atualiza√ß√£o
    this.broadcastQueueUpdate();
  }

  // M√©todo auxiliar para obter nome das lanes
  private getLaneName(laneId: string): string {
    const lanes: { [key: string]: string } = {
      'top': 'Topo',
      'jungle': 'Selva',
      'mid': 'Meio',
      'bot': 'Atirador',
      'support': 'Suporte'
    };
    return lanes[laneId] || laneId;
  } private async processMatchmaking(): Promise<void> {
    console.log(`üîÑ [Matchmaking] Processando matchmaking - ${this.queue.length} jogadores na fila`);

    if (!this.isActive || this.queue.length < 10) {
      console.log(`‚ùå [Matchmaking] Matchmaking n√£o ativo ou jogadores insuficientes: ativo=${this.isActive}, jogadores=${this.queue.length}`);
      return;
    }

    try {
      console.log(`üîç [Matchmaking] Buscando melhor partida...`);
      const match = await this.findBestMatch();

      if (match) {
        console.log('üéÆ Partida encontrada! Criando lobby...', {
          team1Players: match.team1.length,
          team2Players: match.team2.length,
          avgMMR1: Math.round(match.averageMMR1),
          avgMMR2: Math.round(match.averageMMR2)
        });

        // Salvar partida no banco de dados
        await this.createMatchAndNotify(match);

        // Remover jogadores da fila
        const allMatchPlayers = [...match.team1, ...match.team2];
        this.queue = this.queue.filter(player =>
          !allMatchPlayers.some(matchPlayer => matchPlayer.id === player.id)
        );

        // Notificar todos os jogadores da partida
        this.notifyMatchFound(match);

        // Adicionar atividade
        this.addActivity(
          'match_created',
          `Partida criada! ${match.team1.length}v${match.team2.length} - MMR m√©dio: ${Math.round((match.averageMMR1 + match.averageMMR2) / 2)}`
        );

        // Atualizar status da fila
        this.broadcastQueueUpdate();

        console.log('‚úÖ Partida criada com sucesso!');
      } else {
        console.log(`‚ùå [Matchmaking] Nenhuma partida encontrada para ${this.queue.length} jogadores`);
      }
    } catch (error) {
      console.error('‚ùå [Matchmaking] Erro no processamento de matchmaking:', error);
    }
  }

  // M√©todo para criar partida no banco e notificar jogadores
  private async createMatchAndNotify(match: Match): Promise<void> {
    try {
      // Salvar partida no banco de dados como partida personalizada
      const matchId = await this.dbManager.createCustomMatch({
        title: `Partida Automatizada ${new Date().toLocaleString()}`,
        description: `Times balanceados - MMR m√©dio: Time 1: ${Math.round(match.averageMMR1)}, Time 2: ${Math.round(match.averageMMR2)}`,
        team1Players: match.team1.map(p => p.summonerName),
        team2Players: match.team2.map(p => p.summonerName),
        createdBy: 'Sistema de Matchmaking',
        gameMode: 'CLASSIC'
      });

      // Atualizar o ID da partida
      match.id = matchId;

      // Adicionar √† lista de partidas ativas
      this.activeMatches.set(matchId, match);

      // Remover jogadores da fila
      const matchPlayerIds = [...match.team1, ...match.team2].map(p => p.id);
      this.queue = this.queue.filter(p => !matchPlayerIds.includes(p.id));

      // Adicionar atividade
      this.addActivity('match_created', `Partida criada! ${match.team1.length}v${match.team2.length} - MMR m√©dio: ${Math.round((match.averageMMR1 + match.averageMMR2) / 2)}`);

      // Configurar timeout para aceita√ß√£o (30 segundos)
      match.acceptTimeout = setTimeout(() => {
        this.handleMatchTimeout(matchId);
      }, 30000);

      // Notificar todos os jogadores sobre a partida encontrada
      this.notifyMatchFound(match);

      // Auto-aceitar bots ap√≥s 1 segundo (simular tempo de rea√ß√£o)
      setTimeout(() => {
        this.autoAcceptBots(matchId);
      }, 1000);

      // Atualizar status da fila
      this.broadcastQueueUpdate();

      console.log(`üéÆ Partida criada! ID: ${matchId}, Players: ${matchPlayerIds.length}`);
    } catch (error) {
      console.error('Erro ao criar partida:', error);
    }
  }

  // M√©todo para lidar com timeout de aceita√ß√£o
  private handleMatchTimeout(matchId: number): void {
    const match = this.activeMatches.get(matchId);
    if (!match) return;

    const allPlayers = [...match.team1, ...match.team2];
    const nonAcceptedPlayers = allPlayers.filter(p => !match.acceptedPlayers.has(p.id));

    if (nonAcceptedPlayers.length > 0) {
      console.log(`‚è∞ Timeout da partida ${matchId}! Jogadores que n√£o aceitaram:`,
        nonAcceptedPlayers.map(p => p.summonerName));

      // Usar o mesmo m√©todo do bot√£o recusar para cada jogador que n√£o aceitou
      nonAcceptedPlayers.forEach(async (player) => {
        if (player.id > 0) { // Pular bots
          try {
            await this.declineMatch(player.id, matchId, player.summonerName);
            console.log(`‚úÖ [Timeout] ${player.summonerName} removido via declineMatch (timeout)`);
          } catch (error) {
            console.error(`‚ùå [Timeout] Erro ao remover ${player.summonerName} via declineMatch:`, error);
          }
        }
      });
    }
  }

  // M√©todo para auto-aceitar bots
  private autoAcceptBots(matchId: number): void {
    const match = this.activeMatches.get(matchId);
    if (!match) return;

    const allPlayers = [...match.team1, ...match.team2];
    const botPlayers = allPlayers.filter(p => p.id < 0); // Bots t√™m ID negativo

    if (botPlayers.length === 0) {
      console.log(`ü§ñ Nenhum bot encontrado na partida ${matchId}`);
      return;
    }

    console.log(`ü§ñ Auto-aceitando ${botPlayers.length} bots na partida ${matchId}`);

    // Auto-aceitar cada bot com delay para simular tempo de rea√ß√£o
    botPlayers.forEach((bot, index) => {
      setTimeout(() => {
        try {
          // Adicionar bot diretamente aos aceitos sem chamar acceptMatch
          match.acceptedPlayers.add(bot.id);
          console.log(`ü§ñ Bot ${bot.summonerName} aceitou automaticamente`);

          // Verificar se todos os jogadores aceitaram
          const allPlayers = [...match.team1, ...match.team2];
          const allAccepted = allPlayers.every(p => match.acceptedPlayers.has(p.id));

          console.log(`üìä Partida ${matchId}: ${match.acceptedPlayers.size}/${allPlayers.length} aceitaram`);

          if (allAccepted) {
            console.log(`üéâ Todos os jogadores aceitaram a partida ${matchId}! Iniciando draft...`);

            // Limpar timeout se existir
            if (match.acceptTimeout) {
              clearTimeout(match.acceptTimeout);
              match.acceptTimeout = undefined;
            }

            // Iniciar fase de draft
            this.startDraftPhase(matchId);
          }
        } catch (error) {
          console.error(`Erro ao auto-aceitar bot ${bot.summonerName}:`, error);
        }
      }, (index + 1) * 500); // 500ms de delay entre cada bot
    });
  }

  // M√©todo para notificar jogadores sobre partida encontrada
  private notifyMatchFound(match: Match): void {
    const allPlayers = [...match.team1, ...match.team2];

    allPlayers.forEach((player, index) => {
      // Pular bots (eles n√£o t√™m websocket)
      if (!player.websocket || player.id < 0) return;

      const isTeam1 = match.team1.includes(player);
      const team = isTeam1 ? match.team1 : match.team2;
      const enemyTeam = isTeam1 ? match.team2 : match.team1;

      const matchData = {
        matchId: match.id,
        playerSide: isTeam1 ? 'blue' : 'red',
        teammates: team.map(p => ({
          id: p.id,
          summonerName: p.summonerName,
          mmr: p.currentMMR,
          primaryLane: p.preferences?.primaryLane || 'fill',
          secondaryLane: p.preferences?.secondaryLane || 'fill',
          assignedLane: p.preferences?.assignedLane || 'fill',
          isAutofill: p.preferences?.isAutofill || false
        })),
        enemies: enemyTeam.map(p => ({
          id: p.id,
          summonerName: p.summonerName,
          mmr: p.currentMMR,
          primaryLane: p.preferences?.primaryLane || 'fill',
          secondaryLane: p.preferences?.secondaryLane || 'fill',
          assignedLane: p.preferences?.assignedLane || 'fill',
          isAutofill: p.preferences?.isAutofill || false
        })),
        averageMMR: {
          yourTeam: isTeam1 ? match.averageMMR1 : match.averageMMR2,
          enemyTeam: isTeam1 ? match.averageMMR2 : match.averageMMR1
        },
        estimatedGameDuration: 25, // minutos
        phase: 'accept', // accept -> draft -> in_game
        acceptTimeout: 30 // segundos para aceitar
      };

      try {
        player.websocket.send(JSON.stringify({
          type: 'match_found',
          data: matchData
        }));
      } catch (error) {
        console.error(`Erro ao notificar jogador ${player.summonerName}:`, error);
      }
    });
  }

  // M√©todo para aceitar partida
  async acceptMatch(playerId: number, matchId: number, summonerName?: string): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    console.log(`üîç [Matchmaking] Tentativa de aceitar partida - Match ID: ${matchId}, Player ID: ${playerId}, Nome: ${summonerName}`);
    console.log(`üîç [Matchmaking] Jogadores na partida:`, [...match.team1, ...match.team2].map(p => ({ id: p.id, name: p.summonerName })));

    // Procurar jogador - priorizar por nome se dispon√≠vel
    let player: QueuedPlayer | undefined;

    if (summonerName) {
      // Primeira tentativa: buscar por nome exato
      player = [...match.team1, ...match.team2].find(p => p.summonerName === summonerName);

      // Segunda tentativa: buscar por nome parcial (sem tagline)
      if (!player && summonerName.includes('#')) {
        const gameNameOnly = summonerName.split('#')[0];
        player = [...match.team1, ...match.team2].find(p => p.summonerName.startsWith(gameNameOnly + '#'));
      }

      // Terceira tentativa: buscar por gameName apenas
      if (!player) {
        player = [...match.team1, ...match.team2].find(p => p.summonerName.split('#')[0] === summonerName);
      }
    }

    // Se n√£o encontrou por nome, tentar por ID
    if (!player && playerId) {
      player = [...match.team1, ...match.team2].find(p => p.id === playerId);
    }

    if (!player) {
      console.log(`‚ùå [Matchmaking] Jogador n√£o encontrado na partida`);
      console.log(`üîç [Matchmaking] Dados recebidos:`, { playerId, summonerName });
      console.log(`üîç [Matchmaking] Jogadores dispon√≠veis:`, [...match.team1, ...match.team2].map(p => ({ id: p.id, name: p.summonerName })));
      throw new Error('Jogador n√£o est√° nesta partida');
    }

    // Verificar se o jogador j√° aceitou
    if (match.acceptedPlayers.has(player.id)) {
      console.log(`‚ö†Ô∏è [Matchmaking] ${player.summonerName} j√° aceitou a partida ${matchId}`);
      return; // N√£o √© um erro, apenas j√° aceitou
    }

    // Adicionar jogador aos que aceitaram
    match.acceptedPlayers.add(player.id);
    console.log(`‚úÖ [Matchmaking] ${player.summonerName} aceitou a partida ${matchId}`);

    // Verificar se todos os jogadores aceitaram
    const allPlayers = [...match.team1, ...match.team2];
    const allAccepted = allPlayers.every(p => match.acceptedPlayers.has(p.id));

    console.log(`üìä [Matchmaking] Partida ${matchId}: ${match.acceptedPlayers.size}/${allPlayers.length} aceitaram`);

    if (allAccepted) {
      console.log(`üéâ [Matchmaking] Todos os jogadores aceitaram a partida ${matchId}! Iniciando draft...`);

      // Limpar timeout se existir
      if (match.acceptTimeout) {
        clearTimeout(match.acceptTimeout);
        match.acceptTimeout = undefined;
      }

      // Iniciar fase de draft
      this.startDraftPhase(matchId);
    }
  }

  // M√©todo para recusar partida
  async declineMatch(playerId: number, matchId: number, summonerName?: string): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    console.log(`üîç [Matchmaking] Tentativa de recusar partida - Match ID: ${matchId}, Player ID: ${playerId}, Nome: ${summonerName}`);
    console.log(`üîç [Matchmaking] Jogadores na partida:`, [...match.team1, ...match.team2].map(p => ({ id: p.id, name: p.summonerName })));

    // Procurar jogador - priorizar por nome se dispon√≠vel
    let player: QueuedPlayer | undefined;

    if (summonerName) {
      // Primeira tentativa: buscar por nome exato
      player = [...match.team1, ...match.team2].find(p => p.summonerName === summonerName);

      // Segunda tentativa: buscar por nome parcial (sem tagline)
      if (!player && summonerName.includes('#')) {
        const gameNameOnly = summonerName.split('#')[0];
        player = [...match.team1, ...match.team2].find(p => p.summonerName.startsWith(gameNameOnly + '#'));
      }

      // Terceira tentativa: buscar por gameName apenas
      if (!player) {
        player = [...match.team1, ...match.team2].find(p => p.summonerName.split('#')[0] === summonerName);
      }
    }

    // Se n√£o encontrou por nome, tentar por ID
    if (!player && playerId) {
      player = [...match.team1, ...match.team2].find(p => p.id === playerId);
    }

    if (!player) {
      console.log(`‚ùå [Matchmaking] Jogador n√£o encontrado na partida para recusar`);
      console.log(`üîç [Matchmaking] Dados recebidos:`, { playerId, summonerName });
      console.log(`üîç [Matchmaking] Jogadores dispon√≠veis:`, [...match.team1, ...match.team2].map(p => ({ id: p.id, name: p.summonerName })));
      throw new Error('Jogador n√£o est√° nesta partida');
    }

    console.log(`‚ùå [Matchmaking] ${player.summonerName} recusou a partida ${matchId}`);

    // Cancelar partida imediatamente quando algu√©m recusa
    await this.cancelMatch(matchId, `${player.summonerName} recusou a partida`);
  }

  // M√©todo para cancelar partida
  private async cancelMatch(matchId: number, reason: string): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      console.log(`‚ö†Ô∏è [CancelMatch] Partida ${matchId} n√£o encontrada nas partidas ativas`);
      return;
    }

    console.log(`üéâ Partida ${matchId} cancelada por ${reason}`);
    console.log(`üîç [CancelMatch] Dados da partida:`, {
      matchId: matchId,
      matchIdInMatch: match.id,
      team1Size: match.team1.length,
      team2Size: match.team2.length,
      status: match.status
    });

    // Remover partida das ativas
    this.activeMatches.delete(matchId);

    // Limpar timeout se existir
    if (match.acceptTimeout) {
      clearTimeout(match.acceptTimeout);
      match.acceptTimeout = undefined;
    }

    // APAGAR partida do banco de dados se foi salva
    try {
      if (match.id) {
        console.log(`üóëÔ∏è [CancelMatch] Tentando apagar partida ${matchId} do banco (ID: ${match.id})`);
        await this.dbManager.deleteCustomMatch(match.id);
        console.log(`üóëÔ∏è [Matchmaking] Partida ${matchId} apagada do banco de dados (ID: ${match.id})`);
      } else {
        console.log(`‚ö†Ô∏è [Matchmaking] Partida ${matchId} n√£o tem ID no banco para apagar`);
      }
    } catch (error) {
      console.error(`‚ùå [Matchmaking] Erro ao apagar partida ${matchId} do banco:`, error);
    }

    // CORRE√á√ÉO: Apenas quem recusou sai da fila, os outros continuam
    const allPlayers = [...match.team1, ...match.team2];

    // Se a raz√£o indica que algu√©m recusou, identificar quem recusou
    let declinedPlayer: QueuedPlayer | undefined;
    if (reason.includes('recusou a partida')) {
      const playerName = reason.replace(' recusou a partida', '');
      declinedPlayer = allPlayers.find(p => p.summonerName === playerName);
      console.log(`üîç [CancelMatch] Jogador que recusou identificado:`, declinedPlayer?.summonerName);
    }

    const removedPlayers: string[] = [];
    const returnedPlayers: string[] = [];

    // Processar jogadores
    allPlayers.forEach(player => {
      if (player === declinedPlayer) {
        // Apenas quem recusou sai da fila
        const playerIndex = this.queue.findIndex(p => p.id === player.id);
        if (playerIndex !== -1) {
          this.queue.splice(playerIndex, 1);
          removedPlayers.push(player.summonerName);
          console.log(`üóëÔ∏è [CancelMatch] ${player.summonerName} removido da fila (recusou a partida)`);
        }
      } else {
        // Os outros jogadores continuam na fila
        const playerIndex = this.queue.findIndex(p => p.id === player.id);
        if (playerIndex === -1) {
          // Se n√£o est√° na fila, adicionar de volta
          player.websocket = null as any; // Resetar websocket
          this.queue.push(player);
          returnedPlayers.push(player.summonerName);
          console.log(`üîÑ [CancelMatch] ${player.summonerName} retornou √† fila (Bot: ${player.id < 0})`);
        } else {
          console.log(`‚úÖ [CancelMatch] ${player.summonerName} j√° est√° na fila (Bot: ${player.id < 0})`);
        }
      }
    });

    // Notificar jogadores sobre o cancelamento
    allPlayers.forEach(player => {
      if (player.websocket && player.id > 0) { // Pular bots
        try {
          player.websocket.send(JSON.stringify({
            type: 'match_cancelled',
            data: {
              matchId: matchId,
              reason: reason,
              declinedPlayer: declinedPlayer?.summonerName
            }
          }));
        } catch (error) {
          console.error(`Erro ao notificar cancelamento para ${player.summonerName}:`, error);
        }
      }
    });

    // Atualizar posi√ß√µes na fila
    this.queue.forEach((p, index) => {
      p.queuePosition = index + 1;
    });

    // Broadcast atualiza√ß√£o da fila
    this.broadcastQueueUpdate();

    console.log(`‚úÖ [CancelMatch] ${removedPlayers.length} jogador removido da fila:`, removedPlayers);
    console.log(`‚úÖ [CancelMatch] ${returnedPlayers.length} jogadores retornaram √† fila:`, returnedPlayers);
    this.addActivity('match_created', `Partida ${matchId} cancelada por ${reason} - ${removedPlayers.length} jogador removido, ${returnedPlayers.length} retornaram √† fila`);
  }

  // M√©todo para adicionar atividade ao hist√≥rico
  private addActivity(type: QueueActivity['type'], message: string, playerName?: string, playerTag?: string, lane?: string): void {
    const activity: QueueActivity = {
      id: `activity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date(),
      type,
      message,
      playerName,
      playerTag,
      lane
    };

    this.recentActivities.unshift(activity);

    // Manter apenas as √∫ltimas atividades
    if (this.recentActivities.length > this.MAX_ACTIVITIES) {
      this.recentActivities = this.recentActivities.slice(0, this.MAX_ACTIVITIES);
    }
  }

  // M√©todo para calcular tempo estimado de espera
  private calculateEstimatedWaitTime(): number {
    if (this.queue.length < 10) {
      return Math.max(30, this.queue.length * 5); // M√≠nimo 30 segundos
    }
    return 60; // 1 minuto quando h√° jogadores suficientes
  }

  // M√©todo para obter nome de exibi√ß√£o da lane
  private getLaneDisplayName(laneId?: string): string {
    const lanes: { [key: string]: string } = {
      'top': 'Topo',
      'jungle': 'Selva',
      'mid': 'Meio',
      'bot': 'Atirador',
      'support': 'Suporte',
      'fill': 'Preenchimento'
    };
    return lanes[laneId || 'fill'] || 'Preenchimento';
  }

  // M√©todo simplificado para broadcast imediato
  public async broadcastQueueUpdate(force: boolean = false): Promise<void> {
    if (!this.wss) {
      console.log('‚ö†Ô∏è [Matchmaking] WebSocket server n√£o dispon√≠vel para broadcast');
      return;
    }

    const now = Date.now();

    // Prote√ß√£o b√°sica contra spam (m√≠nimo 50ms entre broadcasts para tempo real)
    if (!force && now - this.lastBroadcastTime < 50) {
      console.log(`‚è±Ô∏è [Matchmaking] Broadcast ignorado (throttling): ${now - this.lastBroadcastTime}ms desde √∫ltimo`);
      return;
    }

    this.lastBroadcastTime = now;

    try {
      const queueStatus = await this.getQueueStatus();

      console.log(`üì° [Matchmaking] Enviando broadcast para ${this.wss.clients.size} clientes:`, {
        playersInQueue: queueStatus.playersInQueue,
        playersList: queueStatus.playersInQueueList?.map(p => p.summonerName),
        timestamp: now,
        force: force
      });

      // Preparar dados da fila para broadcast (incluindo informa√ß√µes da fila para Discord)
      const broadcastData = {
        type: 'queue_update',
        data: queueStatus,
        timestamp: now,
        // Adicionar informa√ß√µes extras para Discord
        queuePlayers: queueStatus.playersInQueueList?.map(player => ({
          summonerName: player.summonerName,
          tagLine: player.tagLine,
          primaryLane: player.primaryLane,
          secondaryLane: player.secondaryLane,
          mmr: player.mmr,
          queuePosition: player.queuePosition,
          joinTime: player.joinTime
        })) || []
      };

      // Enviar para todos os clientes conectados
      let sentCount = 0;
      this.wss.clients.forEach((client: WebSocket) => {
        if (client.readyState === WebSocket.OPEN) {
          try {
            client.send(JSON.stringify(broadcastData));
            sentCount++;
          } catch (error) {
            console.error('‚ùå [Matchmaking] Erro ao enviar atualiza√ß√£o da fila:', error);
          }
        }
      });

      console.log(`‚úÖ [Matchmaking] Broadcast enviado para ${sentCount}/${this.wss.clients.size} clientes`);
      console.log(`üìä [Matchmaking] Dados inclu√≠dos: ${broadcastData.queuePlayers.length} jogadores na fila`);

    } catch (error) {
      console.error('‚ùå [Matchmaking] Erro no broadcast da fila:', error);
    }
  }

  // M√©todo para obter status da fila
  async getQueueStatus(): Promise<QueueStatus> {
    const playersInQueueList: QueuedPlayerInfo[] = this.queue.map(player => {
      // Extrair summonerName e tagLine do nome completo
      const fullName = player.summonerName;
      const nameParts = fullName.split('#');
      const summonerName = nameParts[0];
      const tagLine = nameParts.length > 1 ? nameParts[1] : undefined;
      
      return {
        summonerName: summonerName,
        tagLine: tagLine,
        primaryLane: player.preferences?.primaryLane || 'fill',
        secondaryLane: player.preferences?.secondaryLane || 'fill',
        primaryLaneDisplay: this.getLaneDisplayName(player.preferences?.primaryLane),
        secondaryLaneDisplay: this.getLaneDisplayName(player.preferences?.secondaryLane),
        mmr: player.currentMMR,
        queuePosition: player.queuePosition || 0,
        joinTime: player.joinTime
      };
    });

    return {
      playersInQueue: this.queue.length,
      averageWaitTime: this.calculateEstimatedWaitTime(),
      estimatedMatchTime: this.queue.length >= 10 ? 60 : 120,
      isActive: this.isActive,
      playersInQueueList,
      recentActivities: [...this.recentActivities]
    };
  }

  // M√©todo para obter partidas recentes
  async getRecentMatches(): Promise<any[]> {
    try {
      return await this.dbManager.getCustomMatches(10);
    } catch (error) {
      console.error('Erro ao buscar partidas recentes:', error);
      return [];
    }
  }

  // M√©todo para encontrar melhor partida
  private async findBestMatch(): Promise<Match | null> {
    if (this.queue.length < 10) {
      return null;
    }

    console.log(`üîç [Matchmaking] Verificando matchmaking - ${this.queue.length} jogadores na fila`);

    // Filtrar jogadores que n√£o acabaram de ter o draft cancelado (cooldown de 30 segundos)
    const now = Date.now();
    const cooldownMs = 30000; // 30 segundos de cooldown
    const eligiblePlayers = this.queue.filter(player => {
      const draftCancelledAt = (player as any).draftCancelledAt;
      if (!draftCancelledAt) return true; // Jogador nunca teve draft cancelado

      const timeSinceCancel = now - draftCancelledAt;
      const isEligible = timeSinceCancel > cooldownMs;

      if (!isEligible) {
        console.log(`‚è≥ [Matchmaking] ${player.summonerName} ainda em cooldown ap√≥s cancelamento (${Math.floor(timeSinceCancel / 1000)}s restantes)`);
      }

      return isEligible;
    });

    if (eligiblePlayers.length < 10) {
      console.log(`‚è≥ [Matchmaking] Apenas ${eligiblePlayers.length} jogadores eleg√≠veis (cooldown ativo para alguns)`);
      return null;
    }

    // Ordenar jogadores por MMR
    const sortedPlayers = eligiblePlayers.sort((a, b) => b.currentMMR - a.currentMMR);

    console.log(`üìä [Matchmaking] Jogadores ordenados por MMR:`, sortedPlayers.map(p => ({ name: p.summonerName, mmr: p.currentMMR })));

    // Formar times balanceados
    const team1: QueuedPlayer[] = [];
    const team2: QueuedPlayer[] = [];

    // Distribuir jogadores alternadamente para balancear MMR
    for (let i = 0; i < sortedPlayers.length; i++) {
      if (i % 2 === 0) {
        team1.push(sortedPlayers[i]);
      } else {
        team2.push(sortedPlayers[i]);
      }
    }

    console.log(`üë• [Matchmaking] Times formados:`, {
      team1: team1.map(p => ({ name: p.summonerName, mmr: p.currentMMR })),
      team2: team2.map(p => ({ name: p.summonerName, mmr: p.currentMMR }))
    });

    // Calcular MMR m√©dio dos times
    const avgMMR1 = team1.reduce((sum, p) => sum + p.currentMMR, 0) / team1.length;
    const avgMMR2 = team2.reduce((sum, p) => sum + p.currentMMR, 0) / team2.length;
    const mmrDifference = Math.abs(avgMMR1 - avgMMR2);

    console.log(`üìä [Matchmaking] MMR m√©dio: Team1=${Math.round(avgMMR1)}, Team2=${Math.round(avgMMR2)}, Diferen√ßa=${Math.round(mmrDifference)}`);

    // Verificar se a diferen√ßa de MMR √© aceit√°vel (m√°ximo 500)
    if (mmrDifference > 500) {
      console.log(`‚ö†Ô∏è [Matchmaking] Diferen√ßa de MMR muito alta (${Math.round(mmrDifference)}), aguardando mais jogadores`);
      return null;
    }

    // Atribuir lanes baseado no MMR
    this.assignLanesByMMR(team1);
    this.assignLanesByMMR(team2);

    // Criar partida
    const match: Match = {
      id: 0, // Ser√° definido quando salvar no banco
      team1,
      team2,
      createdAt: new Date(),
      status: 'waiting',
      averageMMR1: avgMMR1,
      averageMMR2: avgMMR2,
      acceptedPlayers: new Set()
    };

    console.log(`‚úÖ [Matchmaking] Partida criada com sucesso!`);
    return match;
  }

  // ‚úÖ CORRE√á√ÉO: M√©todo para atribuir lanes em ordem fixa
  private assignLanesByMMR(team: QueuedPlayer[]): void {
    console.log(`üéØ [AssignLanes] Atribuindo lanes para time com ${team.length} jogadores`);
    
    // ‚úÖ CORRE√á√ÉO: Ordem fixa de lanes (√≠ndice 0=top, 1=jungle, 2=mid, 3=adc, 4=support)
    const laneOrder = ['top', 'jungle', 'mid', 'adc', 'support'];
    
    console.log(`üìä [AssignLanes] Jogadores antes da ordena√ß√£o:`, team.map((p, i) => ({
      index: i,
      name: p.summonerName,
      mmr: p.currentMMR,
      primary: p.preferences?.primaryLane,
      secondary: p.preferences?.secondaryLane
    })));

    // ‚úÖ CORRE√á√ÉO: Atribuir lanes baseado na posi√ß√£o no array, n√£o no MMR
    team.forEach((player, index) => {
      const assignedLane = laneOrder[index] || 'fill';
      
      // Verificar se a lane atribu√≠da corresponde √†s prefer√™ncias
      const isPreferred = player.preferences?.primaryLane === assignedLane || 
                         player.preferences?.secondaryLane === assignedLane ||
                         (assignedLane === 'adc' && (player.preferences?.primaryLane === 'bot' || player.preferences?.secondaryLane === 'bot'));
      
      player.preferences = {
        ...player.preferences,
        assignedLane: assignedLane,
        isAutofill: !isPreferred
      };
      
      console.log(`‚úÖ [AssignLanes] Jogador [${index}] ${player.summonerName} -> ${assignedLane} ${isPreferred ? '(prefer√™ncia)' : '(autofill)'}`);
    });

    // Log final das atribui√ß√µes
    console.log(`üìã [AssignLanes] Atribui√ß√µes finais (ordem fixa):`, team.map((p, i) => ({
      index: i,
      name: p.summonerName,
      mmr: p.currentMMR,
      assignedLane: p.preferences?.assignedLane,
      isAutofill: p.preferences?.isAutofill,
      primary: p.preferences?.primaryLane,
      secondary: p.preferences?.secondaryLane
    })));
  }

  // M√©todo para iniciar fase de draft
  private async startDraftPhase(matchId: number): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      console.log(`‚ùå [Draft] Partida ${matchId} n√£o encontrada para iniciar draft`);
      return;
    }

    console.log(`üéØ [Draft] Iniciando fase de draft para partida ${matchId}`);
    console.log(`üéØ [Draft] Jogadores na partida:`, [...match.team1, ...match.team2].map(p => ({ id: p.id, name: p.summonerName })));

    // Atualizar status da partida
    match.status = 'in_progress';

    // Criar dados do draft com a estrutura correta que o frontend espera
    const draftData = {
      matchId: matchId,
      phase: 'draft',
      turnOrder: this.generateDraftTurnOrder(match),
      timeLimit: 30, // segundos por turno
      currentTurn: 0,
      // ‚úÖ CORRE√á√ÉO: Estrutura que o frontend espera com teamIndex correto
      team1: match.team1.map((p, index) => ({
        id: p.id,
        summonerName: p.summonerName,
        name: p.summonerName, // Frontend espera 'name' tamb√©m
        mmr: p.currentMMR,
        primaryLane: p.preferences?.primaryLane || 'fill',
        secondaryLane: p.preferences?.secondaryLane || 'fill',
        assignedLane: p.preferences?.assignedLane || 'fill',
        lane: p.preferences?.assignedLane || 'fill', // ‚úÖ NOVO: Frontend espera 'lane'
        isAutofill: p.preferences?.isAutofill || false,
        teamIndex: index, // ‚úÖ CORRE√á√ÉO: teamIndex baseado na posi√ß√£o no array (0-4)
        originalIndex: index // ‚úÖ NOVO: Manter √≠ndice original
      })),
      team2: match.team2.map((p, index) => ({
        id: p.id,
        summonerName: p.summonerName,
        name: p.summonerName, // Frontend espera 'name' tamb√©m
        mmr: p.currentMMR,
        primaryLane: p.preferences?.primaryLane || 'fill',
        secondaryLane: p.preferences?.secondaryLane || 'fill',
        assignedLane: p.preferences?.assignedLane || 'fill',
        lane: p.preferences?.assignedLane || 'fill', // ‚úÖ NOVO: Frontend espera 'lane'
        isAutofill: p.preferences?.isAutofill || false,
        teamIndex: index, // ‚úÖ CORRE√á√ÉO: teamIndex baseado na posi√ß√£o no array (0-4)
        originalIndex: index // ‚úÖ NOVO: Manter √≠ndice original
      })),
      // Dados adicionais para o draft
      averageMMR: {
        team1: match.averageMMR1,
        team2: match.averageMMR2
      },
      estimatedGameDuration: 25, // minutos
      acceptTimeout: 30 // segundos para aceitar
    };

    console.log(`üéØ [Draft] Dados do draft criados:`, {
      matchId: draftData.matchId,
      team1: draftData.team1.map(p => ({ index: p.teamIndex, name: p.summonerName, lane: p.lane })),
      team2: draftData.team2.map(p => ({ index: p.teamIndex, name: p.summonerName, lane: p.lane }))
    });

    // Notificar jogadores sobre o draft
    this.notifyDraftPhase(match, draftData);

    // Adicionar atividade
    this.addActivity('match_created', `Fase de draft iniciada para partida ${matchId}`);

    console.log(`‚úÖ [Draft] Fase de draft iniciada com sucesso para partida ${matchId}`);
  }

  // M√©todo para gerar ordem de turnos no draft
  private generateDraftTurnOrder(match: Match): number[] {
    const allPlayers = [...match.team1, ...match.team2];
    const turnOrder: number[] = [];

    // Ordem: Team1 ban, Team2 ban, Team1 ban, Team2 ban, Team1 ban, Team2 ban
    // Depois: Team1 pick, Team2 pick, Team2 pick, Team1 pick, Team1 pick, Team2 pick, Team2 pick, Team1 pick, Team1 pick, Team2 pick

    // Bans (6 total)
    for (let i = 0; i < 6; i++) {
      const team = i % 2 === 0 ? match.team1 : match.team2;
      const playerIndex = Math.floor(i / 2) % team.length;
      turnOrder.push(team[playerIndex].id);
    }

    // Picks (10 total)
    const pickOrder = [0, 1, 1, 0, 0, 1, 1, 0, 0, 1]; // 0 = team1, 1 = team2
    pickOrder.forEach((teamIndex, i) => {
      const team = teamIndex === 0 ? match.team1 : match.team2;
      const playerIndex = Math.floor(i / 2) % team.length;
      turnOrder.push(team[playerIndex].id);
    });

    return turnOrder;
  }

  // M√©todo para notificar jogadores sobre fase de draft
  private notifyDraftPhase(match: Match, draftData: any): void {
    const allPlayers = [...match.team1, ...match.team2];

    console.log(`üì° [Draft] Notificando ${allPlayers.length} jogadores sobre o draft`);

    allPlayers.forEach(player => {
      if (player.websocket && player.id > 0) {
        try {
          const message = {
            type: 'draft_started',
            data: draftData
          };

          console.log(`üì° [Draft] Enviando mensagem para ${player.summonerName}:`, message);
          player.websocket.send(JSON.stringify(message));
          console.log(`‚úÖ [Draft] Mensagem enviada com sucesso para ${player.summonerName}`);
        } catch (error) {
          console.error(`‚ùå [Draft] Erro ao notificar draft para ${player.summonerName}:`, error);
        }
      } else {
        console.log(`‚ö†Ô∏è [Draft] Pulando ${player.summonerName} (bot ou sem websocket):`, {
          id: player.id,
          hasWebSocket: !!player.websocket,
          isBot: player.id < 0
        });
      }
    });

    console.log(`üì° [Draft] Notifica√ß√£o de draft conclu√≠da`);
  }

  // M√©todo para processar a√ß√£o do draft
  async processDraftAction(matchId: number, playerId: number, championId: number, action: 'pick' | 'ban'): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    console.log(`üéØ Draft action: ${action} champion ${championId} by player ${playerId} in match ${matchId}`);

    // Aqui voc√™ implementaria a l√≥gica do draft
    // Por enquanto, apenas notificar outros jogadores
    const allPlayers = [...match.team1, ...match.team2];

    allPlayers.forEach(player => {
      if (player.websocket && player.id > 0 && player.id !== playerId) {
        try {
          player.websocket.send(JSON.stringify({
            type: 'draft_action',
            data: {
              matchId,
              playerId,
              championId,
              action
            }
          }));
        } catch (error) {
          console.error(`Erro ao notificar a√ß√£o do draft para ${player.summonerName}:`, error);
        }
      }
    });
  }

  // M√©todo para adicionar jogador √† fila via Discord
  async addPlayerToDiscordQueue(websocket: WebSocket, requestData: any): Promise<void> {
    try {
      // Validar dados da requisi√ß√£o
      if (!requestData || !requestData.discordId || !requestData.gameName || !requestData.tagLine) {
        throw new Error('Dados do Discord incompletos');
      }

      // Construir o nome completo (gameName#tagLine)
      const fullSummonerName = `${requestData.gameName}#${requestData.tagLine}`;
      console.log('üîç [Matchmaking] Nome completo para Discord:', fullSummonerName);
      console.log('üîç [Matchmaking] Dados recebidos:', {
        discordId: requestData.discordId,
        gameName: requestData.gameName,
        tagLine: requestData.tagLine,
        lcuData: requestData.lcuData
      });

      // Buscar link Discord-LoL
      const discordLink = await this.dbManager.getDiscordLink(requestData.discordId);
      console.log('üîç [Matchmaking] Link Discord encontrado:', discordLink);

      if (!discordLink) {
        console.log('‚ùå [Matchmaking] Link Discord n√£o encontrado para ID:', requestData.discordId);
        throw new Error('Conta Discord n√£o vinculada ao LoL');
      }

      console.log('‚úÖ [Matchmaking] Link Discord encontrado:', {
        discordId: discordLink.discord_id,
        gameName: discordLink.game_name,
        tagLine: discordLink.tag_line,
        summonerName: discordLink.summoner_name
      });

      // Verificar se o link ainda √© v√°lido
      const isValid = await this.dbManager.verifyDiscordLink(
        requestData.discordId,
        requestData.gameName,
        requestData.tagLine
      );

      console.log('üîç [Matchmaking] Verifica√ß√£o do link:', {
        discordId: requestData.discordId,
        gameName: requestData.gameName,
        tagLine: requestData.tagLine,
        isValid: isValid
      });

      if (!isValid) {
        // Tentar verificar com dados do link existente
        console.log('üîç [Matchmaking] Link inv√°lido, verificando dados do link existente:', {
          linkGameName: discordLink.game_name,
          linkTagLine: discordLink.tag_line,
          requestGameName: requestData.gameName,
          requestTagLine: requestData.tagLine
        });

        // Se os dados n√£o batem, mas o link existe, usar os dados do link
        if (discordLink.game_name && discordLink.tag_line) {
          console.log('üîÑ [Matchmaking] Usando dados do link existente em vez dos dados da requisi√ß√£o');
          requestData.gameName = discordLink.game_name;
          requestData.tagLine = discordLink.tag_line;

          // Reconstruir o nome completo
          const correctedFullName = `${discordLink.game_name}#${discordLink.tag_line}`;
          console.log('üîÑ [Matchmaking] Nome corrigido:', correctedFullName);

          // Verificar novamente se agora √© v√°lido
          const isValidAfterCorrection = await this.dbManager.verifyDiscordLink(
            requestData.discordId,
            requestData.gameName,
            requestData.tagLine
          );

          if (!isValidAfterCorrection) {
            throw new Error('Dados do LoL n√£o correspondem ao link Discord mesmo ap√≥s corre√ß√£o');
          }

          console.log('‚úÖ [Matchmaking] Link v√°lido ap√≥s corre√ß√£o dos dados');
        } else {
          throw new Error('Dados do LoL n√£o correspondem ao link Discord');
        }
      }

      // VERIFICA√á√ÉO CR√çTICA: Verificar se o jogador est√° detectado pelo LCU
      const lcuData = requestData.lcuData;
      if (!lcuData || !lcuData.gameName || !lcuData.tagLine) {
        throw new Error('Jogador n√£o detectado pelo LCU. Certifique-se de estar logado no LoL');
      }

      // Verificar se os dados do LCU correspondem aos dados do Discord
      const lcuFullName = `${lcuData.gameName}#${lcuData.tagLine}`;
      const discordFullName = `${requestData.gameName}#${requestData.tagLine}`;

      console.log('üîç [Matchmaking] Comparando dados LCU vs Discord:', {
        lcuData: lcuData,
        lcuFullName: lcuFullName,
        discordData: {
          gameName: requestData.gameName,
          tagLine: requestData.tagLine
        },
        discordFullName: discordFullName,
        match: lcuFullName === discordFullName
      });

      // Se os dados n√£o batem exatamente, mas temos um link Discord v√°lido, usar os dados do Discord
      if (lcuFullName !== discordFullName) {
        console.log('‚ö†Ô∏è [Matchmaking] Dados do LCU e Discord n√£o batem, mas link Discord √© v√°lido. Usando dados do Discord.');
        // Continuar com os dados do Discord, j√° que o link foi validado
      }

      console.log('‚úÖ [Matchmaking] Jogador detectado pelo LCU e Discord:', lcuFullName);

      // Buscar jogador no banco usando o nome completo
      let player = await this.dbManager.getPlayerBySummonerName(discordFullName);
      if (!player) {
        // Se n√£o encontrou pelo nome completo, tentar pelo nome do link
        player = await this.dbManager.getPlayerBySummonerName(discordLink.summoner_name);
        if (!player) {
          throw new Error('Jogador n√£o encontrado no banco de dados');
        }
        // Atualizar o nome no banco para o formato completo
        await this.dbManager.updatePlayerSummonerName(player.id!, discordFullName);
        player.summoner_name = discordFullName;
        console.log('‚úÖ [Matchmaking] Nome do jogador atualizado para formato completo:', discordFullName);
      }

      // PRIMEIRO: Verificar se j√° est√° na fila no MySQL
      const existingInDB = await this.dbManager.getActiveQueuePlayers();
      const isAlreadyInQueue = existingInDB.some(dbPlayer => 
        dbPlayer.summoner_name === discordFullName ||
        dbPlayer.player_id === player?.id
      );

      if (isAlreadyInQueue) {
        console.log(`‚ö†Ô∏è [Matchmaking] Jogador ${discordFullName} j√° est√° na fila (MySQL)`);
        const playerInQueue = existingInDB.find(p => 
          p.summoner_name === discordFullName || p.player_id === player?.id
        );
        websocket.send(JSON.stringify({
          type: 'queue_joined',
          data: {
            position: playerInQueue?.queue_position || 0,
            estimatedWait: this.calculateEstimatedWaitTime(),
            queueStatus: await this.getQueueStatus()
          }
        }));
        return;
      }

      // SEGUNDO: Verificar se j√° est√° na fila local (e atualizar websocket se necess√°rio)
      const existingPlayerIndex = this.queue.findIndex(p => 
        p.summonerName === discordFullName || p.id === player?.id
      );
      
      if (existingPlayerIndex !== -1) {
        // Atualizar websocket se jogador reconectar
        this.queue[existingPlayerIndex].websocket = websocket;
        console.log('üîÑ [Matchmaking] Jogador j√° na fila via Discord, atualizando WebSocket:', discordFullName);
        websocket.send(JSON.stringify({
          type: 'queue_joined',
          data: { 
            position: existingPlayerIndex + 1, 
            estimatedWait: this.calculateEstimatedWaitTime(),
            queueStatus: await this.getQueueStatus()
          }
        }));
        return;
      }

      // TERCEIRO: Adicionar ao MySQL PRIMEIRO
      await this.dbManager.addPlayerToQueue(
        player.id!,
        discordFullName, // Nome completo
        player.region,
        player.custom_lp || 0,
        requestData.preferences
      );

      // QUARTO: Adicionar √† fila local
      const queuedPlayer: QueuedPlayer = {
        id: player.id!,
        summonerName: discordFullName, // Usar nome completo
        region: player.region,
        currentMMR: player.custom_lp || 0,
        joinTime: new Date(),
        websocket: websocket,
        queuePosition: this.queue.length + 1,
        preferences: requestData.preferences || { primaryLane: 'fill', secondaryLane: 'fill' }
      };

      console.log('üîç [Matchmaking] Prefer√™ncias do jogador:', {
        receivedPreferences: requestData.preferences,
        finalPreferences: queuedPlayer.preferences,
        primaryLane: queuedPlayer.preferences?.primaryLane,
        secondaryLane: queuedPlayer.preferences?.secondaryLane
      });

      this.queue.push(queuedPlayer);

      // QUINTO: Atualizar posi√ß√µes na fila ap√≥s adicionar o jogador
      await this.updateQueuePositions();

      // SEXTO: Adicionar atividade
      const primaryLaneName = this.getLaneDisplayName(queuedPlayer.preferences?.primaryLane);
      this.addActivity(
        'player_joined',
        `${discordFullName} entrou na fila`,
        discordFullName,
        queuedPlayer.preferences?.primaryLane
      );

      // S√âTIMO: Notificar jogador
      websocket.send(JSON.stringify({
        type: 'queue_joined',
        data: {
          position: this.queue.length,
          estimatedWait: this.calculateEstimatedWaitTime(),
          queueStatus: await this.getQueueStatus()
        }
      }));

      // OITAVO: Broadcast atualiza√ß√£o da fila (for√ßar imediatamente para entrada)
      await this.forceQueueUpdate();

      console.log(`‚úÖ [Matchmaking] ${discordFullName} entrou na fila via Discord (MySQL + Local)`);

    } catch (error: any) {
      console.error('‚ùå [Matchmaking] Erro ao adicionar jogador √† fila via Discord:', error);
      websocket.send(JSON.stringify({
        type: 'error',
        message: 'Falha ao entrar na fila via Discord: ' + error.message
      }));
    }
  }

  // M√©todo para obter fila atual
  public getQueue(): QueuedPlayer[] {
    return [...this.queue];
  }

  // M√©todo para remover jogador da fila por ID ou nome
  public async removePlayerFromQueueById(playerId?: number, summonerName?: string): Promise<boolean> {
    console.log(`üîç [Matchmaking] Tentando remover jogador da fila:`, { playerId, summonerName });

    try {
      // PRIMEIRO: Remover do MySQL
      let removedFromDB = false;
      
      if (playerId) {
        await this.dbManager.removePlayerFromQueue(playerId);
        removedFromDB = true;
        console.log(`‚úÖ [Matchmaking] Jogador ID ${playerId} removido do MySQL`);
      } else if (summonerName) {
        // Buscar o ID do jogador no banco primeiro
        const dbPlayers = await this.dbManager.getActiveQueuePlayers();
        const dbPlayer = dbPlayers.find(p => 
          p.summoner_name === summonerName ||
          // Tamb√©m verificar se o summonerName fornecido √© compat√≠vel (gameName#tagLine)
          (p.summoner_name.includes('#') && summonerName.includes('#') && 
           p.summoner_name === summonerName) ||
          // Verificar se √© s√≥ o gameName sem tagLine
          (p.summoner_name.includes('#') && !summonerName.includes('#') &&
           p.summoner_name.startsWith(summonerName + '#'))
        );
        
        if (dbPlayer) {
          await this.dbManager.removePlayerFromQueue(dbPlayer.player_id);
          removedFromDB = true;
          console.log(`‚úÖ [Matchmaking] Jogador ${summonerName} removido do MySQL (ID: ${dbPlayer.player_id})`);
        }
      }

      // SEGUNDO: Remover da fila local
      let playerIndex = -1;

      if (playerId) {
        playerIndex = this.queue.findIndex(p => p.id === playerId);
      } else if (summonerName) {
        playerIndex = this.queue.findIndex(p => 
          p.summonerName === summonerName ||
          // Tamb√©m verificar se o summonerName fornecido √© compat√≠vel (gameName#tagLine)
          (p.summonerName.includes('#') && summonerName.includes('#') && 
           p.summonerName === summonerName) ||
          // Verificar se √© s√≥ o gameName sem tagLine
          (p.summonerName.includes('#') && !summonerName.includes('#') &&
           p.summonerName.startsWith(summonerName + '#'))
        );
      }

      if (playerIndex !== -1) {
        const player = this.queue[playerIndex];
        console.log(`‚úÖ [Matchmaking] Removendo jogador da fila local:`, { id: player.id, name: player.summonerName });

        this.queue.splice(playerIndex, 1);

        // Adicionar atividade
        this.addActivity(
          'player_left',
          `${player.summonerName} saiu da fila`,
          player.summonerName
        );

        // Atualizar posi√ß√µes na fila
        await this.updateQueuePositions();

        // Broadcast atualiza√ß√£o da fila
        await this.broadcastQueueUpdate();

        console.log(`‚ûñ [Matchmaking] ${player.summonerName} removido da fila (MySQL + Local)`);
        return true;
      } else {
        console.log(`‚ö†Ô∏è [Matchmaking] Jogador n√£o encontrado na fila local:`, { playerId, summonerName });
        return removedFromDB; // Retorna true se foi removido do MySQL mesmo que n√£o estivesse na fila local
      }

    } catch (error) {
      console.error('‚ùå [Matchmaking] Erro ao remover jogador da fila:', error);
      return false;
    }
  }

  // M√©todo para desligar o servi√ßo
  public shutdown(): void {
    this.isActive = false;

    if (this.matchmakingInterval) {
      clearInterval(this.matchmakingInterval);
      this.matchmakingInterval = null;
    }

    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    // NOVO: Limpar intervalo de sincroniza√ß√£o MySQL
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }

    // Limpar timeouts das partidas ativas
    this.activeMatches.forEach(match => {
      if (match.acceptTimeout) {
        clearTimeout(match.acceptTimeout);
      }
    });

    console.log('üõë Servi√ßo de matchmaking desligado');
  }

  // M√©todo para verificar se o servi√ßo est√° ativo
  public isServiceActive(): boolean {
    return this.isActive;
  }

  // M√©todo para for√ßar atualiza√ß√£o imediata (usado para a√ß√µes cr√≠ticas)
  public async forceQueueUpdate(): Promise<void> {
    console.log('üöÄ [Matchmaking] For√ßando atualiza√ß√£o imediata da fila...');
    await this.broadcastQueueUpdate(true);
  }

  // M√©todo para atualizar partida ap√≥s picks/bans completados
  async updateMatchAfterDraft(matchId: number, draftData: any): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    console.log(`üéØ [Draft] Atualizando partida ${matchId} ap√≥s draft completado`);

    try {
      // Atualizar partida no banco com dados do draft
      await this.dbManager.updateCustomMatch(matchId, {
        title: `Partida com Draft - ${new Date().toLocaleString()}`,
        description: `Draft completado - MMR m√©dio: Time 1: ${Math.round(match.averageMMR1)}, Time 2: ${Math.round(match.averageMMR2)}`,
        status: 'draft_completed',
        draft_data: draftData // Salvar dados do draft
      });

      console.log(`‚úÖ [Draft] Partida ${matchId} atualizada com dados do draft`);
    } catch (error) {
      console.error(`‚ùå [Draft] Erro ao atualizar partida ${matchId} ap√≥s draft:`, error);
      throw error;
    }
  }

  // M√©todo para finalizar partida ap√≥s jogo completado (usando completeCustomMatch que j√° funciona)
  async completeMatchAfterGame(matchId: number, winnerTeam: number, gameData: any): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    console.log(`üèÅ [Game] Finalizando partida ${matchId} ap√≥s jogo completado - Vencedor: Time ${winnerTeam}`);

    try {
      // Usar o m√©todo completeCustomMatch que j√° funciona corretamente
      await this.dbManager.completeCustomMatch(matchId, winnerTeam, {
        duration: gameData.duration || 0,
        pickBanData: gameData.pickBanData || null,
        participantsData: gameData.participantsData || null,
        detectedByLCU: gameData.detectedByLCU || false,
        riotGameId: gameData.riotGameId || null,
        notes: `Partida finalizada via matchmaking - ${gameData.notes || 'Jogo completado'}`
      });

      // Remover da lista de partidas ativas
      this.activeMatches.delete(matchId);

      console.log(`‚úÖ [Game] Partida ${matchId} finalizada com sucesso usando completeCustomMatch`);
    } catch (error) {
      console.error(`‚ùå [Game] Erro ao finalizar partida ${matchId}:`, error);
      throw error;
    }
  }

  // M√©todo para cancelar draft e remover partida do banco
  async cancelDraft(matchId: number, reason: string): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      console.log(`‚ö†Ô∏è [CancelDraft] Partida ${matchId} n√£o encontrada nas partidas ativas`);
      return;
    }

    console.log(`üéâ [CancelDraft] Draft da partida ${matchId} cancelado por ${reason}`);
    console.log(`üîç [CancelDraft] Dados da partida:`, {
      matchId: matchId,
      matchIdInMatch: match.id,
      team1Size: match.team1.length,
      team2Size: match.team2.length,
      status: match.status
    });

    // Remover partida das ativas
    this.activeMatches.delete(matchId);

    // APAGAR partida do banco de dados se foi salva
    try {
      if (match.id) {
        console.log(`üóëÔ∏è [CancelDraft] Tentando apagar partida ${matchId} do banco (ID: ${match.id})`);
        await this.dbManager.deleteCustomMatch(match.id);
        console.log(`üóëÔ∏è [CancelDraft] Partida ${matchId} apagada do banco de dados (ID: ${match.id})`);
      } else {
        console.log(`‚ö†Ô∏è [CancelDraft] Partida ${matchId} n√£o tem ID no banco para apagar`);
      }
    } catch (error) {
      console.error(`‚ùå [CancelDraft] Erro ao apagar partida ${matchId} do banco:`, error);
    }

    // CORRE√á√ÉO: Apenas o jogador que cancelou sai da fila, os outros continuam
    const allPlayers = [...match.team1, ...match.team2];
    const removedPlayers: string[] = [];
    const returnedPlayers: string[] = [];

    // Identificar quem cancelou (assumindo que √© o primeiro jogador real, n√£o bot)
    const cancellingPlayer = allPlayers.find(p => p.id > 0); // Primeiro jogador real

    allPlayers.forEach(player => {
      if (player === cancellingPlayer) {
        // Apenas quem cancelou sai da fila
        const playerIndex = this.queue.findIndex(p => p.id === player.id);
        if (playerIndex !== -1) {
          this.queue.splice(playerIndex, 1);
          removedPlayers.push(player.summonerName);
          console.log(`üóëÔ∏è [CancelDraft] ${player.summonerName} removido da fila (cancelou o draft)`);
        }
      } else {
        // Os outros jogadores continuam na fila
        const playerIndex = this.queue.findIndex(p => p.id === player.id);
        if (playerIndex === -1) {
          // Se n√£o est√° na fila, adicionar de volta
          player.websocket = null as any; // Resetar websocket
          this.queue.push(player);
          returnedPlayers.push(player.summonerName);
          console.log(`üîÑ [CancelDraft] ${player.summonerName} retornou √† fila (Bot: ${player.id < 0})`);
        } else {
          console.log(`‚úÖ [CancelDraft] ${player.summonerName} j√° est√° na fila (Bot: ${player.id < 0})`);
        }
      }

      // Notificar jogador sobre o cancelamento do draft
      if (player.websocket && player.id > 0) { // Pular bots
        try {
          const message = {
            type: 'draft_cancelled',
            data: {
              matchId: matchId,
              reason: reason
            }
          };

          console.log(`üì° [CancelDraft] Enviando mensagem para ${player.summonerName}:`, JSON.stringify(message, null, 2));
          player.websocket.send(JSON.stringify(message));
          console.log(`‚úÖ [CancelDraft] Mensagem enviada com sucesso para ${player.summonerName}`);
        } catch (error) {
          console.error(`‚ùå [CancelDraft] Erro ao notificar cancelamento do draft para ${player.summonerName}:`, error);
        }
      }
    });

    // Atualizar posi√ß√µes na fila
    this.queue.forEach((p, index) => {
      p.queuePosition = index + 1;
    });

    // Broadcast atualiza√ß√£o da fila
    this.broadcastQueueUpdate();

    console.log(`‚úÖ [CancelDraft] ${removedPlayers.length} jogador removido da fila:`, removedPlayers);
    console.log(`‚úÖ [CancelDraft] ${returnedPlayers.length} jogadores retornaram √† fila:`, returnedPlayers);
    this.addActivity('match_created', `Draft da partida ${matchId} cancelado por ${reason} - ${removedPlayers.length} jogador removido, ${returnedPlayers.length} retornaram √† fila`);
  }

  // M√©todo para cancelar partida em andamento (ap√≥s o draft)
  async cancelGameInProgress(matchId: number, reason: string): Promise<void> {
    console.log(`üîç [CancelGameInProgress] Iniciando cancelamento para matchId: ${matchId}`);
    console.log(`üîç [CancelGameInProgress] Tipo do matchId: ${typeof matchId}`);
    console.log(`üîç [CancelGameInProgress] Reason: ${reason}`);
    
    const match = this.activeMatches.get(matchId);
    if (!match) {
      console.log(`‚ö†Ô∏è [CancelGameInProgress] Partida ${matchId} n√£o encontrada nas partidas ativas`);
      console.log(`üîç [CancelGameInProgress] Partidas ativas dispon√≠veis:`, Array.from(this.activeMatches.keys()));
      return;
    }

    console.log(`üéâ [CancelGameInProgress] Partida em andamento ${matchId} cancelada por ${reason}`);
    console.log(`üîç [CancelGameInProgress] Dados da partida:`, {
      matchId: matchId,
      matchIdInMatch: match.id,
      team1Size: match.team1.length,
      team2Size: match.team2.length,
      status: match.status
    });

    // Remover partida das ativas
    this.activeMatches.delete(matchId);

    // APAGAR partida do banco de dados se foi salva
    try {
      if (match.id) {
        console.log(`üóëÔ∏è [CancelGameInProgress] Tentando apagar partida ${matchId} do banco (ID: ${match.id})`);
        await this.dbManager.deleteCustomMatch(match.id);
        console.log(`üóëÔ∏è [CancelGameInProgress] Partida ${matchId} apagada do banco de dados (ID: ${match.id})`);
      } else {
        console.log(`‚ö†Ô∏è [CancelGameInProgress] Partida ${matchId} n√£o tem ID no banco para apagar`);
      }
    } catch (error) {
      console.error(`‚ùå [CancelGameInProgress] Erro ao apagar partida ${matchId} do banco:`, error);
    }

    // CORRE√á√ÉO: Remover jogadores da fila ao inv√©s de retorn√°-los
    const allPlayers = [...match.team1, ...match.team2];
    const removedPlayers: string[] = [];

    allPlayers.forEach(player => {
      // Remover jogador da fila
      const playerIndex = this.queue.findIndex(p => p.id === player.id);
      if (playerIndex !== -1) {
        this.queue.splice(playerIndex, 1);
        removedPlayers.push(player.summonerName);
        console.log(`üóëÔ∏è [CancelGameInProgress] ${player.summonerName} removido da fila ap√≥s cancelamento da partida (Bot: ${player.id < 0})`);
      } else {
        console.log(`‚ö†Ô∏è [CancelGameInProgress] ${player.summonerName} n√£o encontrado na fila para remo√ß√£o`);
      }

      // Notificar jogador sobre o cancelamento da partida
      if (player.websocket && player.id > 0) { // Pular bots
        try {
          const message = {
            type: 'game_cancelled',
            data: {
              matchId: matchId,
              reason: reason
            }
          };

          console.log(`üì° [CancelGameInProgress] Enviando mensagem para ${player.summonerName}:`, JSON.stringify(message, null, 2));
          player.websocket.send(JSON.stringify(message));
          console.log(`‚úÖ [CancelGameInProgress] Mensagem enviada com sucesso para ${player.summonerName}`);
        } catch (error) {
          console.error(`‚ùå [CancelGameInProgress] Erro ao notificar cancelamento da partida para ${player.summonerName}:`, error);
        }
      }
    });

    // Atualizar posi√ß√µes na fila
    this.queue.forEach((p, index) => {
      p.queuePosition = index + 1;
    });

    // Broadcast atualiza√ß√£o da fila
    this.broadcastQueueUpdate();

    console.log(`‚úÖ [CancelGameInProgress] ${removedPlayers.length} jogadores removidos da fila:`, removedPlayers);
    this.addActivity('match_created', `Partida em andamento ${matchId} cancelada por ${reason} - ${removedPlayers.length} jogadores removidos da fila`);
  }

  // NOVO: Iniciar intervalo de matchmaking
  private startMatchmakingInterval(): void {
    if (this.matchmakingInterval) {
      clearInterval(this.matchmakingInterval);
    }

    this.matchmakingInterval = setInterval(() => {
      this.processMatchmaking();
    }, 5000);

    console.log('üîÑ [Matchmaking] Intervalo de matchmaking iniciado (5s)');
  }

  // NOVO: Iniciar intervalo de limpeza
  private startCleanupInterval(): void {
    console.log('‚ö†Ô∏è [Cleanup] Limpeza autom√°tica DESABILITADA para preservar dados');
    console.log('üîß [Cleanup] Limpeza ser√° executada apenas sob demanda ou em casos cr√≠ticos');
    
    // ‚úÖ DESABILITADO: Limpeza autom√°tica a cada 30 segundos
    // Motivo: Prevenir remo√ß√£o n√£o intencional de jogadores da fila
    /*
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }

    this.cleanupInterval = setInterval(() => {
      this.cleanupInactivePlayers();
    }, this.CLEANUP_INTERVAL_MS);

    console.log(`üîÑ [Cleanup] Intervalo de limpeza iniciado (${this.CLEANUP_INTERVAL_MS}ms)`);
    */
  }

  private async createMatch(players: QueuedPlayer[]): Promise<void> {
    if (players.length !== 10) {
      console.log('‚ö†Ô∏è [Matchmaking] Tentativa de criar partida com n√∫mero incorreto de jogadores:', players.length);
      return;
    }

    console.log('üéØ [Matchmaking] Criando partida com 10 jogadores...');

    try {
      // PRIMEIRO: Remover todos os jogadores do MySQL
      for (const player of players) {
        await this.dbManager.removePlayerFromQueue(player.id);
        console.log(`üóëÔ∏è [Matchmaking] Jogador ${player.summonerName} removido do MySQL (partida iniciada)`);
      }

      // SEGUNDO: Remover da fila local
      for (const player of players) {
        const playerIndex = this.queue.findIndex(p => p.id === player.id);
        if (playerIndex !== -1) {
          this.queue.splice(playerIndex, 1);
          console.log(`üóëÔ∏è [Matchmaking] Jogador ${player.summonerName} removido da fila local (partida iniciada)`);
        }
      }

      // TERCEIRO: Atualizar posi√ß√µes no MySQL
      await this.updateQueuePositions();

      // QUARTO: Criar a partida
      const matchId = this.nextMatchId++;
      
      // Dividir jogadores em duas equipes
      const team1 = players.slice(0, 5);
      const team2 = players.slice(5, 10);
      
      const match: Match = {
        id: matchId,
        team1: team1,
        team2: team2,
        status: 'waiting_accept',
        createdAt: new Date(),
        averageMMR1: team1.reduce((sum, p) => sum + p.currentMMR, 0) / team1.length,
        averageMMR2: team2.reduce((sum, p) => sum + p.currentMMR, 0) / team2.length,
        acceptedPlayers: new Set(),
        acceptTimeout: undefined
      };

      this.activeMatches.set(matchId, match);

      // QUINTO: Configurar timeout de aceita√ß√£o
      match.acceptTimeout = setTimeout(() => {
        this.cancelMatch(matchId, 'Timeout de aceita√ß√£o expirado');
      }, 30000); // 30 segundos

      // SEXTO: Notificar jogadores sobre a partida encontrada
      for (const player of players) {
        if (player.websocket && player.websocket.readyState === WebSocket.OPEN) {
          try {
            const matchData = {
              type: 'match_found',
              data: {
                matchId: matchId,
                players: players.map(p => ({
                  id: p.id,
                  summonerName: p.summonerName,
                  region: p.region,
                  currentMMR: p.currentMMR,
                  preferences: p.preferences
                })),
                timeout: 30
              }
            };

            player.websocket.send(JSON.stringify(matchData));
            console.log(`üì° [Matchmaking] Notifica√ß√£o de partida enviada para ${player.summonerName}`);
          } catch (error) {
            console.error(`‚ùå [Matchmaking] Erro ao notificar ${player.summonerName}:`, error);
          }
        }
      }

      // S√âTIMO: Adicionar atividade
      this.addActivity(
        'match_created',
        `Partida ${matchId} criada com ${players.length} jogadores`
      );

      // OITAVO: Broadcast atualiza√ß√£o da fila
      await this.broadcastQueueUpdate();

      console.log(`‚úÖ [Matchmaking] Partida ${matchId} criada com sucesso. Jogadores removidos da fila.`);

    } catch (error) {
      console.error('‚ùå [Matchmaking] Erro ao criar partida:', error);
    }
  }

  // ‚úÖ NOVO: M√©todo p√∫blico para sincroniza√ß√£o manual sob demanda
  public async forceMySQLSync(): Promise<void> {
    console.log('üîÑ [MySQL Sync] Sincroniza√ß√£o manual solicitada...');
    try {
      await this.syncQueueWithDatabase();
      console.log('‚úÖ [MySQL Sync] Sincroniza√ß√£o manual conclu√≠da');
    } catch (error) {
      console.error('‚ùå [MySQL Sync] Erro na sincroniza√ß√£o manual:', error);
      throw error;
    }
  }
}