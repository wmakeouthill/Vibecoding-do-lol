import { DatabaseManager } from '../database/DatabaseManager';
import { WebSocket } from 'ws';

// Interfaces
interface QueuedPlayer {
  id: number;
  summonerName: string;
  region: string;
  currentMMR: number;
  joinTime: Date;
  websocket: WebSocket;
  queuePosition?: number;
  preferences?: {
    primaryLane?: string;
    secondaryLane?: string;
    autoAccept?: boolean;
    assignedLane?: string;
    isAutofill?: boolean;
  };
}

interface Match {
  id: number;
  team1: QueuedPlayer[];
  team2: QueuedPlayer[];
  createdAt: Date;
  status: 'waiting' | 'in_progress' | 'completed';
  averageMMR1: number;
  averageMMR2: number;
  acceptedPlayers: Set<number>; // IDs dos jogadores que aceitaram
  acceptTimeout?: NodeJS.Timeout; // Timer para timeout da aceita√ß√£o
}

interface QueueStatus {
  playersInQueue: number;
  averageWaitTime: number;
  estimatedMatchTime: number;
  isActive: boolean;
  playersInQueueList?: QueuedPlayerInfo[];
  recentActivities?: QueueActivity[];
}

interface QueuedPlayerInfo {
  summonerName: string;
  tagLine?: string;
  primaryLane: string;
  secondaryLane: string;
  primaryLaneDisplay: string;
  secondaryLaneDisplay: string;
  mmr: number;
  queuePosition: number;
  joinTime: Date;
}

interface QueueActivity {
  id: string;
  timestamp: Date;
  type: 'player_joined' | 'player_left' | 'match_created' | 'system_update' | 'queue_cleared';
  message: string;
  playerName?: string;
  playerTag?: string;
  lane?: string;
}

export class MatchmakingService {
  private dbManager: DatabaseManager;
  private wss: any; // WebSocketServer
  private queue: QueuedPlayer[] = [];
  private activeMatches: Map<number, Match> = new Map();
  private matchmakingInterval: NodeJS.Timeout | null = null;
  private cleanupInterval: NodeJS.Timeout | null = null; // Novo: intervalo de limpeza
  private isActive = true;
  private recentActivities: QueueActivity[] = [];
  private readonly MAX_ACTIVITIES = 20;
  private readonly QUEUE_TIMEOUT_MINUTES = 120; // Timeout para jogadores inativos (2 horas)
  private readonly CLEANUP_INTERVAL_MS = 30000; // Limpeza a cada 30 segundos

  constructor(dbManager: DatabaseManager, wss?: any) {
    this.dbManager = dbManager;
    this.wss = wss;
  }

  async initialize(): Promise<void> {
    // Carregar jogadores da fila persistente
    await this.loadQueueFromDatabase();
    
    // Adicionar atividades iniciais
    this.addActivity('system_update', 'Sistema de matchmaking inicializado');
    this.addActivity('system_update', 'Aguardando jogadores para a fila');    
    
    // Iniciar processamento de matchmaking a cada 5 segundos
    this.matchmakingInterval = setInterval(() => {
      this.processMatchmaking();
    }, 5000);

    // Iniciar limpeza autom√°tica de jogadores inativos a cada 30 segundos
    this.cleanupInterval = setInterval(() => {
      this.cleanupInactivePlayers();
    }, this.CLEANUP_INTERVAL_MS);

    console.log('‚úÖ Sistema de matchmaking ativo com limpeza autom√°tica');
  }

  // Novo m√©todo: Limpeza autom√°tica de jogadores inativos
  private async cleanupInactivePlayers(): Promise<void> {
    try {
      const now = new Date();
      const timeoutMs = this.QUEUE_TIMEOUT_MINUTES * 60 * 1000;
      const playersToRemove: QueuedPlayer[] = [];

      console.log(`üîç Verificando ${this.queue.length} jogadores na fila para limpeza...`);

      // Verificar jogadores inativos
      for (const player of this.queue) {
        const timeInQueue = now.getTime() - player.joinTime.getTime();
        const timeInQueueMinutes = Math.floor(timeInQueue / (1000 * 60));
        const isWebSocketDead = player.websocket && 
          (player.websocket.readyState === WebSocket.CLOSED || 
           player.websocket.readyState === WebSocket.CLOSING);

        // Log do estado do jogador
        console.log(`üë§ ${player.summonerName}: ${timeInQueueMinutes}min na fila, WebSocket: ${player.websocket ? 'ativo' : 'null'}`);

        // Remover se:
        // 1. WebSocket est√° morto (jogador desconectou) OU
        // 2. Jogador est√° na fila h√° mais tempo que o timeout (3 horas)
        if (isWebSocketDead || timeInQueue > timeoutMs) {
          const reason = isWebSocketDead ? 'WebSocket inativo' : 'Timeout de 3 horas';
          console.log(`‚ö†Ô∏è Marcando ${player.summonerName} para remo√ß√£o: ${reason}`);
          playersToRemove.push(player);
        }
      }

      // Remover jogadores inativos
      for (const player of playersToRemove) {
        const playerIndex = this.queue.findIndex(p => p.id === player.id);
        if (playerIndex !== -1) {
          this.queue.splice(playerIndex, 1);
          
          // Persistir sa√≠da da fila no banco
          await this.dbManager.removePlayerFromQueue(player.id);
          
          // Adicionar atividade de sa√≠da autom√°tica
          this.addActivity(
            'player_left',
            `${player.summonerName} removido automaticamente da fila (inativo)`,
            player.summonerName
          );
          
          console.log(`üßπ Removido jogador inativo: ${player.summonerName}`);
        }
      }

      // Atualizar posi√ß√µes na fila se houve remo√ß√µes
      if (playersToRemove.length > 0) {
        this.queue.forEach((p, index) => {
          p.queuePosition = index + 1;
        });
        
        // Broadcast atualiza√ß√£o da fila
        await this.broadcastQueueUpdate();
        
        console.log(`üßπ Limpeza conclu√≠da: ${playersToRemove.length} jogadores removidos`);
      } else {
        console.log(`‚úÖ Nenhum jogador removido na limpeza autom√°tica`);
      }
    } catch (error) {
      console.error('‚ùå Erro na limpeza autom√°tica:', error);
    }
  }

  // M√©todo para verificar se um WebSocket est√° ativo
  private isWebSocketActive(websocket: WebSocket): boolean {
    return websocket && 
           websocket.readyState === WebSocket.OPEN;
  }

  // M√©todo para carregar fila do banco de dados
  private async loadQueueFromDatabase(): Promise<void> {
    try {
      const queuePlayers = await this.dbManager.getActiveQueuePlayers();
      
      for (const dbPlayer of queuePlayers) {
        const queuedPlayer: QueuedPlayer = {
          id: dbPlayer.player_id,
          summonerName: dbPlayer.summoner_name,
          region: dbPlayer.region,
          currentMMR: dbPlayer.custom_lp || 0,
          joinTime: new Date(dbPlayer.join_time),
          websocket: null as any, // WebSocket ser√° atualizado quando o jogador reconectar
          queuePosition: dbPlayer.queue_position,
          preferences: {
            primaryLane: dbPlayer.primary_lane || 'fill',
            secondaryLane: dbPlayer.secondary_lane || 'fill'
          }
        };
        
        this.queue.push(queuedPlayer);
      }
      
      console.log(`üìä Carregados ${this.queue.length} jogadores da fila persistente`);
    } catch (error) {
      console.error('‚ùå Erro ao carregar fila do banco:', error);
    }
  }

  async addPlayerToQueue(websocket: WebSocket, requestData: any): Promise<void> {
    try {
      // Validar dados da requisi√ß√£o
      if (!requestData) {
        throw new Error('Dados da requisi√ß√£o n√£o fornecidos');
      }
      
      // Extrair player e preferences dos dados
      const playerData = requestData.player;
      const preferences = requestData.preferences;
      
      console.log('üîç [Matchmaking] Dados recebidos - playerData:', playerData);
      console.log('üîç [Matchmaking] Dados recebidos - preferences:', preferences);

      // Validar dados do jogador
      if (!playerData) {
        throw new Error('Dados do jogador n√£o fornecidos');
      }

      // Construir o nome completo (gameName#tagLine)
      let fullSummonerName = playerData.summonerName;
      if (playerData.gameName && playerData.tagLine) {
        fullSummonerName = `${playerData.gameName}#${playerData.tagLine}`;
        console.log('üîç [Matchmaking] Nome completo constru√≠do:', fullSummonerName);
      } else if (!playerData.summonerName) {
        throw new Error('Nome do invocador √© obrigat√≥rio');
      }

      console.log('üîç [Matchmaking] Nome final para busca/cria√ß√£o:', fullSummonerName);

      // Buscar jogador no banco ou criar novo
      let player = await this.dbManager.getPlayerBySummonerName(fullSummonerName);
      if (!player) {
        // Criar novo jogador se n√£o existir
        const playerId = await this.dbManager.createPlayer({
          summoner_name: fullSummonerName,
          summoner_id: playerData.summonerId,
          puuid: playerData.puuid,
          region: playerData.region || 'br1',
          current_mmr: 1000,
          peak_mmr: 1000,
          games_played: 0,
          wins: 0,
          losses: 0,
          win_streak: 0,
          custom_lp: 0 // Inicializar custom_lp
        });
        player = await this.dbManager.getPlayer(playerId);
        console.log('‚úÖ [Matchmaking] Novo jogador criado:', { id: playerId, name: fullSummonerName });
      }

      if (!player) {
        throw new Error('Falha ao criar/recuperar jogador');
      }

      // Verificar se jogador j√° est√° na fila
      const existingPlayerIndex = this.queue.findIndex(p => p.id === player!.id);
      if (existingPlayerIndex !== -1) {
        // Atualizar websocket se jogador reconectar
        this.queue[existingPlayerIndex].websocket = websocket;
        console.log('üîÑ [Matchmaking] Jogador j√° na fila, atualizando WebSocket:', fullSummonerName);
        websocket.send(JSON.stringify({
          type: 'queue_joined',
          data: { position: existingPlayerIndex + 1, estimated_wait: this.calculateEstimatedWaitTime() }
        }));
        return;
      }

      // Adicionar √† fila
      const queuedPlayer: QueuedPlayer = {
        id: player.id!,
        summonerName: fullSummonerName, // Usar nome completo
        region: player.region,
        currentMMR: player.custom_lp || 0, // Usar custom_lp em vez de current_mmr
        joinTime: new Date(),
        websocket: websocket,
        queuePosition: this.queue.length + 1,
        preferences: preferences
      };

      console.log('üîç [Matchmaking] Prefer√™ncias do jogador:', {
        receivedPreferences: preferences,
        finalPreferences: queuedPlayer.preferences,
        primaryLane: queuedPlayer.preferences?.primaryLane,
        secondaryLane: queuedPlayer.preferences?.secondaryLane
      });

      this.queue.push(queuedPlayer);

      // Persistir entrada na fila no banco
      await this.dbManager.addPlayerToQueue(
        queuedPlayer.id, 
        queuedPlayer.summonerName, // Nome completo
        queuedPlayer.region, 
        queuedPlayer.currentMMR, 
        preferences
      );

      // Adicionar atividade
      const primaryLaneName = this.getLaneDisplayName(preferences?.primaryLane);
      this.addActivity(
        'player_joined', 
        `${fullSummonerName} entrou na fila como ${primaryLaneName}`,
        fullSummonerName,
        undefined,
        preferences?.primaryLane
      );

      console.log(`‚úÖ [Matchmaking] ${fullSummonerName} entrou na fila como ${primaryLaneName}`);

      // Notificar jogador sobre entrada na fila
      websocket.send(JSON.stringify({
        type: 'queue_joined',
        data: {
          position: this.queue.length,
          estimatedWait: this.calculateEstimatedWaitTime(),
          queueStatus: await this.getQueueStatus()
        }
      }));

      // Broadcast atualiza√ß√£o da fila
      await this.broadcastQueueUpdate();

      console.log(`‚ûï [Matchmaking] ${fullSummonerName} entrou na fila (Posi√ß√£o: ${this.queue.length}, MMR: ${player.custom_lp})`);

    } catch (error: any) {
      console.error('‚ùå [Matchmaking] Erro ao adicionar jogador √† fila:', error);
      websocket.send(JSON.stringify({
        type: 'error',
        message: 'Falha ao entrar na fila: ' + error.message
      }));
    }
  }

  async removePlayerFromQueue(websocket: WebSocket): Promise<void> {
    console.log('üîç [Matchmaking] removePlayerFromQueue chamado via WebSocket');
    console.log('üîç [Matchmaking] Fila atual:', this.queue.map(p => ({ id: p.id, name: p.summonerName, wsActive: p.websocket?.readyState === WebSocket.OPEN })));
    
    const playerIndex = this.queue.findIndex(player => player.websocket === websocket);
    console.log('üîç [Matchmaking] Player index encontrado:', playerIndex);
    console.log('üîç [Matchmaking] Tamanho da fila antes:', this.queue.length);
    
    if (playerIndex !== -1) {
      const player = this.queue[playerIndex];
      console.log('‚úÖ [Matchmaking] Removendo jogador:', { id: player.id, name: player.summonerName });
      
      this.queue.splice(playerIndex, 1);

      // Persistir sa√≠da da fila no banco
      this.dbManager.removePlayerFromQueue(player.id).then(() => {
        console.log(`‚úÖ [Matchmaking] Jogador ${player.summonerName} removido da fila persistente`);
      }).catch(error => {
        console.error('‚ùå [Matchmaking] Erro ao remover jogador da fila persistente:', error);
      });

      // Adicionar atividade de sa√≠da
      this.addActivity(
        'player_left',
        `${player.summonerName} saiu da fila`,
        player.summonerName
      );

      // Atualizar posi√ß√µes na fila
      this.queue.forEach((p, index) => {
        p.queuePosition = index + 1;
      });

      console.log(`‚ûñ [Matchmaking] ${player.summonerName} saiu da fila`);
      console.log('üîç [Matchmaking] Tamanho da fila depois:', this.queue.length);
      console.log('üîç [Matchmaking] Nova fila:', this.queue.map(p => ({ id: p.id, name: p.summonerName })));
      
      await this.broadcastQueueUpdate();
    } else {
      console.log('‚ö†Ô∏è [Matchmaking] Jogador n√£o encontrado na fila para remo√ß√£o via WebSocket');
      console.log('üîç [Matchmaking] WebSocket recebido:', websocket);
      console.log('üîç [Matchmaking] WebSockets na fila:', this.queue.map(p => ({ name: p.summonerName, ws: p.websocket, wsState: p.websocket?.readyState })));
    }
  }

  // M√©todo para adicionar jogador √† fila sem WebSocket (para uso autom√°tico)
  addPlayerToQueueDirect(playerData: any): void {
    try {
      // Verificar se o jogador j√° est√° na fila
      const existingPlayer = this.queue.find(p => p.id === playerData.id);      if (existingPlayer) {
        // console.log(`‚ö†Ô∏è Jogador ${playerData.summonerName} j√° est√° na fila`);
        return;
      }

      const queuedPlayer: QueuedPlayer = {
        id: playerData.id,
        summonerName: playerData.summonerName,
        region: playerData.region,
        currentMMR: playerData.currentMMR,
        joinTime: new Date(),
        websocket: null as any, // Para entrada autom√°tica, sem WebSocket
        queuePosition: this.queue.length + 1
      };

      this.queue.push(queuedPlayer);
        // Registrar entrada na fila no banco
      this.dbManager.recordQueueAction('join', queuedPlayer.id);
      
      console.log(`üéØ Jogador ${playerData.summonerName} adicionado √† fila automaticamente (posi√ß√£o ${queuedPlayer.queuePosition})`);
      
      // Notificar outros jogadores via WebSocket sobre atualiza√ß√£o da fila
      this.broadcastQueueUpdate();
    } catch (error) {
      console.error('Erro ao adicionar jogador √† fila:', error);
    }
  }

  // M√©todo tempor√°rio para adicionar bots na fila (apenas para testes)
  async addBotToQueue(): Promise<void> {
    const availableLanes = ['top', 'jungle', 'mid', 'bot', 'support'];
    const usedLanes = this.queue.map(p => p.preferences?.primaryLane).filter(Boolean);
    const availableUnusedLanes = availableLanes.filter(lane => !usedLanes.includes(lane));
    
    // Se n√£o h√° lanes livres, usar lane aleat√≥ria mesmo assim
    const selectedLanes = availableUnusedLanes.length > 0 ? availableUnusedLanes : availableLanes;
    const primaryLane = selectedLanes[Math.floor(Math.random() * selectedLanes.length)];
    
    // Selecionar lane secund√°ria diferente da prim√°ria
    let secondaryLane = availableLanes.filter(lane => lane !== primaryLane)[Math.floor(Math.random() * 4)];
    
    const botNumber = this.queue.filter(p => p.summonerName.startsWith('Bot')).length + 1;
    const botName = `Bot${botNumber}`;
    
    // Gerar MMR aleat√≥rio entre 800 e 2000
    const randomMMR = Math.floor(Math.random() * 1200) + 800;
    
    const botPlayer: QueuedPlayer = {
      id: -botNumber, // ID negativo para distinguir de jogadores reais
      summonerName: botName,
      region: 'br1',
      currentMMR: randomMMR,
      joinTime: new Date(),
      websocket: null as any, // Bots n√£o t√™m WebSocket
      queuePosition: this.queue.length + 1,
      preferences: {
        primaryLane: primaryLane,
        secondaryLane: secondaryLane,
        autoAccept: true
      }
    };

    this.queue.push(botPlayer);
    
    // Adicionar atividade
    const primaryLaneName = this.getLaneName(primaryLane);
    this.addActivity(
      'player_joined',
      `ü§ñ ${botName} (Bot) entrou na fila como ${primaryLaneName}`,
      botName,
      undefined,
      primaryLane
    );

    console.log(`ü§ñ Bot ${botName} adicionado √† fila - Lane: ${primaryLaneName}, MMR: ${randomMMR}`);
    
    // Notificar todos os clientes sobre a atualiza√ß√£o
    this.broadcastQueueUpdate();
  }

  // M√©todo auxiliar para obter nome das lanes
  private getLaneName(laneId: string): string {
    const lanes: { [key: string]: string } = {
      'top': 'Topo',
      'jungle': 'Selva', 
      'mid': 'Meio',
      'bot': 'Atirador',
      'support': 'Suporte'
    };
    return lanes[laneId] || laneId;
  }  private async processMatchmaking(): Promise<void> {
    if (!this.isActive || this.queue.length < 10) return; // Precisa de 10 jogadores

    try {
      const match = await this.findBestMatch();
      if (match) {
        console.log('üéÆ Partida encontrada! Criando lobby...', {
          team1Players: match.team1.length,
          team2Players: match.team2.length,
          avgMMR1: Math.round(match.averageMMR1),
          avgMMR2: Math.round(match.averageMMR2)
        });

        // Salvar partida no banco de dados
        await this.createMatchAndNotify(match);

        // Remover jogadores da fila
        const allMatchPlayers = [...match.team1, ...match.team2];
        this.queue = this.queue.filter(player => 
          !allMatchPlayers.some(matchPlayer => matchPlayer.id === player.id)
        );

        // Notificar todos os jogadores da partida
        this.notifyMatchFound(match);

        // Adicionar atividade
        this.addActivity(
          'match_created',
          `Partida criada! ${match.team1.length}v${match.team2.length} - MMR m√©dio: ${Math.round((match.averageMMR1 + match.averageMMR2) / 2)}`
        );

        // Atualizar status da fila
        this.broadcastQueueUpdate();

        console.log('‚úÖ Partida criada com sucesso!');
      }
    } catch (error) {
      console.error('Erro no processamento de matchmaking:', error);
    }  }

  // M√©todo para criar partida no banco e notificar jogadores
  private async createMatchAndNotify(match: Match): Promise<void> {
    try {
      // Salvar partida no banco de dados como partida personalizada
      const matchId = await this.dbManager.createCustomMatch({
        title: `Partida Automatizada ${new Date().toLocaleString()}`,
        description: `Times balanceados - MMR m√©dio: Time 1: ${Math.round(match.averageMMR1)}, Time 2: ${Math.round(match.averageMMR2)}`,
        team1Players: match.team1.map(p => p.summonerName),
        team2Players: match.team2.map(p => p.summonerName),
        createdBy: 'Sistema de Matchmaking',
        gameMode: 'CLASSIC'
      });

      // Atualizar o ID da partida
      match.id = matchId;
      
      // Adicionar √† lista de partidas ativas
      this.activeMatches.set(matchId, match);

      // Remover jogadores da fila
      const matchPlayerIds = [...match.team1, ...match.team2].map(p => p.id);
      this.queue = this.queue.filter(p => !matchPlayerIds.includes(p.id));

      // Adicionar atividade
      this.addActivity('match_created', `Partida criada! ${match.team1.length}v${match.team2.length} - MMR m√©dio: ${Math.round((match.averageMMR1 + match.averageMMR2) / 2)}`);

      // Configurar timeout para aceita√ß√£o (30 segundos)
      match.acceptTimeout = setTimeout(() => {
        this.handleMatchTimeout(matchId);
      }, 30000);

      // Notificar todos os jogadores sobre a partida encontrada
      this.notifyMatchFound(match);

      // Auto-aceitar bots ap√≥s 1 segundo (simular tempo de rea√ß√£o)
      setTimeout(() => {
        this.autoAcceptBots(matchId);
      }, 1000);

      // Atualizar status da fila
      this.broadcastQueueUpdate();

      console.log(`üéÆ Partida criada! ID: ${matchId}, Players: ${matchPlayerIds.length}`);
    } catch (error) {
      console.error('Erro ao criar partida:', error);
    }
  }

  // M√©todo para lidar com timeout de aceita√ß√£o
  private handleMatchTimeout(matchId: number): void {
    const match = this.activeMatches.get(matchId);
    if (!match) return;

    const allPlayers = [...match.team1, ...match.team2];
    const nonAcceptedPlayers = allPlayers.filter(p => !match.acceptedPlayers.has(p.id));

    if (nonAcceptedPlayers.length > 0) {
      console.log(`‚è∞ Timeout da partida ${matchId}! Jogadores que n√£o aceitaram:`, 
        nonAcceptedPlayers.map(p => p.summonerName));

      // Notificar jogadores sobre o timeout
      allPlayers.forEach(player => {
        if (player.websocket && player.id > 0) { // Pular bots
          try {
            player.websocket.send(JSON.stringify({
              type: 'match_timeout',
              data: { matchId: matchId }
            }));
          } catch (error) {
            console.error(`Erro ao notificar timeout para ${player.summonerName}:`, error);
          }
        }
      });

      // Remover partida das ativas
      this.activeMatches.delete(matchId);

      // Retornar jogadores que aceitaram para a fila
      const acceptedPlayers = allPlayers.filter(p => match.acceptedPlayers.has(p.id) && p.id > 0);
      acceptedPlayers.forEach(player => {
        this.queue.push(player);
      });

      // Atualizar status da fila
      this.broadcastQueueUpdate();

      this.addActivity('match_created', `Partida ${matchId} cancelada por timeout`);
    }
  }

  // M√©todo para auto-aceitar bots
  private autoAcceptBots(matchId: number): void {
    const match = this.activeMatches.get(matchId);
    if (!match) return;

    const allPlayers = [...match.team1, ...match.team2];
    const botPlayers = allPlayers.filter(p => p.id < 0); // Bots t√™m ID negativo

    if (botPlayers.length === 0) {
      console.log(`ü§ñ Nenhum bot encontrado na partida ${matchId}`);
      return;
    }

    console.log(`ü§ñ Auto-aceitando ${botPlayers.length} bots na partida ${matchId}`);
    
    // Auto-aceitar cada bot
    botPlayers.forEach(bot => {
      try {
        this.acceptMatch(bot.id, matchId, bot.summonerName);
        console.log(`ü§ñ Bot ${bot.summonerName} aceitou automaticamente`);
      } catch (error) {
        console.error(`Erro ao auto-aceitar bot ${bot.summonerName}:`, error);
      }
    });
  }

  // M√©todo para notificar jogadores sobre partida encontrada
  private notifyMatchFound(match: Match): void {
    const allPlayers = [...match.team1, ...match.team2];
    
    allPlayers.forEach((player, index) => {
      // Pular bots (eles n√£o t√™m websocket)
      if (!player.websocket || player.id < 0) return;

      const isTeam1 = match.team1.includes(player);
      const team = isTeam1 ? match.team1 : match.team2;
      const enemyTeam = isTeam1 ? match.team2 : match.team1;

      const matchData = {
        matchId: match.id,
        playerSide: isTeam1 ? 'blue' : 'red',
        teammates: team.map(p => ({
          id: p.id,
          summonerName: p.summonerName,
          mmr: p.currentMMR,
          primaryLane: p.preferences?.primaryLane || 'fill',
          secondaryLane: p.preferences?.secondaryLane || 'fill'
        })),
        enemies: enemyTeam.map(p => ({
          id: p.id,
          summonerName: p.summonerName,
          mmr: p.currentMMR,
          primaryLane: p.preferences?.primaryLane || 'fill',
          secondaryLane: p.preferences?.secondaryLane || 'fill'
        })),
        averageMMR: {
          yourTeam: isTeam1 ? match.averageMMR1 : match.averageMMR2,
          enemyTeam: isTeam1 ? match.averageMMR2 : match.averageMMR1
        },
        estimatedGameDuration: 25, // minutos
        phase: 'accept', // accept -> draft -> in_game
        acceptTimeout: 30 // segundos para aceitar
      };

      try {
        player.websocket.send(JSON.stringify({
          type: 'match_found',
          data: matchData
        }));
      } catch (error) {
        console.error(`Erro ao notificar jogador ${player.summonerName}:`, error);
      }
    });
  }  // M√©todo para aceitar partida
  async acceptMatch(playerId: number, matchId: number, summonerName?: string): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    // Procurar jogador por ID ou por nome
    let player = [...match.team1, ...match.team2].find(p => p.id === playerId);
    
    // Se n√£o encontrou por ID, tentar por nome (√∫til para casos onde o ID pode estar inconsistente)
    if (!player && summonerName) {
      player = [...match.team1, ...match.team2].find(p => p.summonerName === summonerName);
    }
    
    if (!player) {
      console.log(`üîç Tentativa de aceitar partida - Player ID: ${playerId}, Nome: ${summonerName}`);
      console.log(`üîç Jogadores na partida:`, [...match.team1, ...match.team2].map(p => ({ id: p.id, name: p.summonerName })));
      throw new Error('Jogador n√£o est√° nesta partida');
    }

    // Adicionar jogador aos que aceitaram
    match.acceptedPlayers.add(player.id);
    console.log(`‚úÖ ${player.summonerName} aceitou a partida ${matchId}`);
    
    // Verificar se todos os jogadores aceitaram
    const allPlayers = [...match.team1, ...match.team2];
    const allAccepted = allPlayers.every(p => match.acceptedPlayers.has(p.id));
    
    console.log(`üìä Partida ${matchId}: ${match.acceptedPlayers.size}/${allPlayers.length} aceitaram`);
    
    if (allAccepted) {
      console.log(`üéâ Todos os jogadores aceitaram a partida ${matchId}! Iniciando draft...`);
      
      // Limpar timeout se existir
      if (match.acceptTimeout) {
        clearTimeout(match.acceptTimeout);
        match.acceptTimeout = undefined;
      }
      
      // Iniciar fase de draft
      this.startDraftPhase(matchId);
    }
  }

  // M√©todo para recusar partida
  async declineMatch(playerId: number, matchId: number, summonerName?: string): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    // Procurar jogador por ID ou por nome
    let player = [...match.team1, ...match.team2].find(p => p.id === playerId);
    
    if (!player && summonerName) {
      player = [...match.team1, ...match.team2].find(p => p.summonerName === summonerName);
    }
    
    if (!player) {
      throw new Error('Jogador n√£o est√° nesta partida');
    }

    console.log(`‚ùå ${player.summonerName} recusou a partida ${matchId}`);
    
    // Cancelar partida imediatamente quando algu√©m recusa
    this.cancelMatch(matchId, `${player.summonerName} recusou a partida`);
  }

  // M√©todo para cancelar partida
  private cancelMatch(matchId: number, reason: string): void {
    const match = this.activeMatches.get(matchId);
    if (!match) return;

    console.log(`üéâ Partida ${matchId} cancelada por ${reason}`);
    
    // Remover partida das ativas
    this.activeMatches.delete(matchId);

    // Retornar jogadores que aceitaram para a fila
    const acceptedPlayers = [...match.team1, ...match.team2].filter(p => match.acceptedPlayers.has(p.id) && p.id > 0);
    acceptedPlayers.forEach(player => {
      this.queue.push(player);
    });

    // Atualizar status da fila
    this.broadcastQueueUpdate();

    this.addActivity('match_created', `Partida ${matchId} cancelada por ${reason}`);
  }

  // M√©todo para adicionar atividade ao hist√≥rico
  private addActivity(type: QueueActivity['type'], message: string, playerName?: string, playerTag?: string, lane?: string): void {
    const activity: QueueActivity = {
      id: `activity_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date(),
      type,
      message,
      playerName,
      playerTag,
      lane
    };

    this.recentActivities.unshift(activity);

    // Manter apenas as √∫ltimas atividades
    if (this.recentActivities.length > this.MAX_ACTIVITIES) {
      this.recentActivities = this.recentActivities.slice(0, this.MAX_ACTIVITIES);
    }
  }

  // M√©todo para calcular tempo estimado de espera
  private calculateEstimatedWaitTime(): number {
    if (this.queue.length < 10) {
      return Math.max(30, this.queue.length * 5); // M√≠nimo 30 segundos
    }
    return 60; // 1 minuto quando h√° jogadores suficientes
  }

  // M√©todo para obter nome de exibi√ß√£o da lane
  private getLaneDisplayName(laneId?: string): string {
    const lanes: { [key: string]: string } = {
      'top': 'Topo',
      'jungle': 'Selva',
      'mid': 'Meio',
      'bot': 'Atirador',
      'support': 'Suporte',
      'fill': 'Preenchimento'
    };
    return lanes[laneId || 'fill'] || 'Preenchimento';
  }

  // M√©todo para broadcast de atualiza√ß√£o da fila
  public async broadcastQueueUpdate(): Promise<void> {
    if (!this.wss) return;

    const queueStatus = await this.getQueueStatus();
    
    this.wss.clients.forEach((client: WebSocket) => {
      if (client.readyState === WebSocket.OPEN) {
        try {
          client.send(JSON.stringify({
            type: 'queue_update',
            data: queueStatus
          }));
        } catch (error) {
          console.error('Erro ao enviar atualiza√ß√£o da fila:', error);
        }
      }
    });
  }

  // M√©todo para obter status da fila
  async getQueueStatus(): Promise<QueueStatus> {
    const playersInQueueList: QueuedPlayerInfo[] = this.queue.map(player => ({
      summonerName: player.summonerName,
      primaryLane: player.preferences?.primaryLane || 'fill',
      secondaryLane: player.preferences?.secondaryLane || 'fill',
      primaryLaneDisplay: this.getLaneDisplayName(player.preferences?.primaryLane),
      secondaryLaneDisplay: this.getLaneDisplayName(player.preferences?.secondaryLane),
      mmr: player.currentMMR,
      queuePosition: player.queuePosition || 0,
      joinTime: player.joinTime
    }));

    return {
      playersInQueue: this.queue.length,
      averageWaitTime: this.calculateEstimatedWaitTime(),
      estimatedMatchTime: this.queue.length >= 10 ? 60 : 120,
      isActive: this.isActive,
      playersInQueueList,
      recentActivities: [...this.recentActivities]
    };
  }

  // M√©todo para obter partidas recentes
  async getRecentMatches(): Promise<any[]> {
    try {
      return await this.dbManager.getCustomMatches(10);
    } catch (error) {
      console.error('Erro ao buscar partidas recentes:', error);
      return [];
    }
  }

  // M√©todo para encontrar melhor partida
  private async findBestMatch(): Promise<Match | null> {
    if (this.queue.length < 10) return null;

    // Ordenar jogadores por MMR
    const sortedPlayers = [...this.queue].sort((a, b) => a.currentMMR - b.currentMMR);
    
    // Dividir em dois times balanceados
    const team1: QueuedPlayer[] = [];
    const team2: QueuedPlayer[] = [];
    
    // Distribuir jogadores alternadamente para balancear MMR
    for (let i = 0; i < sortedPlayers.length && i < 10; i++) {
      if (i % 2 === 0) {
        team1.push(sortedPlayers[i]);
      } else {
        team2.push(sortedPlayers[i]);
      }
    }

    if (team1.length < 5 || team2.length < 5) return null;

    // Calcular MMR m√©dio dos times
    const avgMMR1 = team1.reduce((sum, p) => sum + p.currentMMR, 0) / team1.length;
    const avgMMR2 = team2.reduce((sum, p) => sum + p.currentMMR, 0) / team2.length;

    // Verificar se a diferen√ßa de MMR √© aceit√°vel (m√°ximo 200)
    if (Math.abs(avgMMR1 - avgMMR2) > 200) return null;

    // Atribuir lanes baseado no MMR
    this.assignLanesByMMR(team1);
    this.assignLanesByMMR(team2);

    const match: Match = {
      id: Date.now(),
      team1,
      team2,
      createdAt: new Date(),
      status: 'waiting',
      averageMMR1: avgMMR1,
      averageMMR2: avgMMR2,
      acceptedPlayers: new Set()
    };

    return match;
  }

  // M√©todo para atribuir lanes baseado no MMR
  private assignLanesByMMR(team: QueuedPlayer[]): void {
    // Ordenar por MMR (maior MMR = lane mais importante)
    const sortedByMMR = [...team].sort((a, b) => b.currentMMR - a.currentMMR);
    
    const lanes = ['mid', 'jungle', 'top', 'bot', 'support'];
    
    sortedByMMR.forEach((player, index) => {
      if (index < lanes.length) {
        player.preferences = {
          ...player.preferences,
          assignedLane: lanes[index],
          isAutofill: false
        };
      }
    });
  }

  // M√©todo para iniciar fase de draft
  private async startDraftPhase(matchId: number): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) return;

    console.log(`üéØ Iniciando fase de draft para partida ${matchId}`);

    // Atualizar status da partida
    match.status = 'in_progress';

    // Criar dados do draft
    const draftData = {
      matchId: matchId,
      phase: 'draft',
      turnOrder: this.generateDraftTurnOrder(match),
      timeLimit: 30, // segundos por turno
      currentTurn: 0
    };

    // Notificar jogadores sobre o draft
    this.notifyDraftPhase(match, draftData);

    // Adicionar atividade
    this.addActivity('match_created', `Fase de draft iniciada para partida ${matchId}`);
  }

  // M√©todo para gerar ordem de turnos no draft
  private generateDraftTurnOrder(match: Match): number[] {
    const allPlayers = [...match.team1, ...match.team2];
    const turnOrder: number[] = [];
    
    // Ordem: Team1 ban, Team2 ban, Team1 ban, Team2 ban, Team1 ban, Team2 ban
    // Depois: Team1 pick, Team2 pick, Team2 pick, Team1 pick, Team1 pick, Team2 pick, Team2 pick, Team1 pick, Team1 pick, Team2 pick
    
    // Bans (6 total)
    for (let i = 0; i < 6; i++) {
      const team = i % 2 === 0 ? match.team1 : match.team2;
      const playerIndex = Math.floor(i / 2) % team.length;
      turnOrder.push(team[playerIndex].id);
    }
    
    // Picks (10 total)
    const pickOrder = [0, 1, 1, 0, 0, 1, 1, 0, 0, 1]; // 0 = team1, 1 = team2
    pickOrder.forEach((teamIndex, i) => {
      const team = teamIndex === 0 ? match.team1 : match.team2;
      const playerIndex = Math.floor(i / 2) % team.length;
      turnOrder.push(team[playerIndex].id);
    });
    
    return turnOrder;
  }

  // M√©todo para notificar jogadores sobre fase de draft
  private notifyDraftPhase(match: Match, draftData: any): void {
    const allPlayers = [...match.team1, ...match.team2];
    
    allPlayers.forEach(player => {
      if (player.websocket && player.id > 0) {
        try {
          player.websocket.send(JSON.stringify({
            type: 'draft_started',
            data: draftData
          }));
        } catch (error) {
          console.error(`Erro ao notificar draft para ${player.summonerName}:`, error);
        }
      }
    });
  }

  // M√©todo para processar a√ß√£o do draft
  async processDraftAction(matchId: number, playerId: number, championId: number, action: 'pick' | 'ban'): Promise<void> {
    const match = this.activeMatches.get(matchId);
    if (!match) {
      throw new Error('Partida n√£o encontrada');
    }

    console.log(`üéØ Draft action: ${action} champion ${championId} by player ${playerId} in match ${matchId}`);

    // Aqui voc√™ implementaria a l√≥gica do draft
    // Por enquanto, apenas notificar outros jogadores
    const allPlayers = [...match.team1, ...match.team2];
    
    allPlayers.forEach(player => {
      if (player.websocket && player.id > 0 && player.id !== playerId) {
        try {
          player.websocket.send(JSON.stringify({
            type: 'draft_action',
            data: {
              matchId,
              playerId,
              championId,
              action
            }
          }));
        } catch (error) {
          console.error(`Erro ao notificar a√ß√£o do draft para ${player.summonerName}:`, error);
        }
      }
    });
  }

  // M√©todo para adicionar jogador √† fila via Discord
  async addPlayerToDiscordQueue(websocket: WebSocket, requestData: any): Promise<void> {
    try {
      // Validar dados da requisi√ß√£o
      if (!requestData || !requestData.discordId || !requestData.gameName || !requestData.tagLine) {
        throw new Error('Dados do Discord incompletos');
      }

      // Construir o nome completo (gameName#tagLine)
      const fullSummonerName = `${requestData.gameName}#${requestData.tagLine}`;
      console.log('üîç [Matchmaking] Nome completo para Discord:', fullSummonerName);
      console.log('üîç [Matchmaking] Dados recebidos:', {
        discordId: requestData.discordId,
        gameName: requestData.gameName,
        tagLine: requestData.tagLine,
        lcuData: requestData.lcuData
      });

      // Buscar link Discord-LoL
      const discordLink = await this.dbManager.getDiscordLink(requestData.discordId);
      console.log('üîç [Matchmaking] Link Discord encontrado:', discordLink);
      
      if (!discordLink) {
        console.log('‚ùå [Matchmaking] Link Discord n√£o encontrado para ID:', requestData.discordId);
        throw new Error('Conta Discord n√£o vinculada ao LoL');
      }

      console.log('‚úÖ [Matchmaking] Link Discord encontrado:', {
        discordId: discordLink.discord_id,
        gameName: discordLink.game_name,
        tagLine: discordLink.tag_line,
        summonerName: discordLink.summoner_name
      });

      // Verificar se o link ainda √© v√°lido
      const isValid = await this.dbManager.verifyDiscordLink(
        requestData.discordId, 
        requestData.gameName, 
        requestData.tagLine
      );

      console.log('üîç [Matchmaking] Verifica√ß√£o do link:', {
        discordId: requestData.discordId,
        gameName: requestData.gameName,
        tagLine: requestData.tagLine,
        isValid: isValid
      });

      if (!isValid) {
        // Tentar verificar com dados do link existente
        console.log('üîç [Matchmaking] Link inv√°lido, verificando dados do link existente:', {
          linkGameName: discordLink.game_name,
          linkTagLine: discordLink.tag_line,
          requestGameName: requestData.gameName,
          requestTagLine: requestData.tagLine
        });
        
        // Se os dados n√£o batem, mas o link existe, usar os dados do link
        if (discordLink.game_name && discordLink.tag_line) {
          console.log('üîÑ [Matchmaking] Usando dados do link existente em vez dos dados da requisi√ß√£o');
          requestData.gameName = discordLink.game_name;
          requestData.tagLine = discordLink.tag_line;
          
          // Reconstruir o nome completo
          const correctedFullName = `${discordLink.game_name}#${discordLink.tag_line}`;
          console.log('üîÑ [Matchmaking] Nome corrigido:', correctedFullName);
          
          // Verificar novamente se agora √© v√°lido
          const isValidAfterCorrection = await this.dbManager.verifyDiscordLink(
            requestData.discordId, 
            requestData.gameName, 
            requestData.tagLine
          );
          
          if (!isValidAfterCorrection) {
            throw new Error('Dados do LoL n√£o correspondem ao link Discord mesmo ap√≥s corre√ß√£o');
          }
          
          console.log('‚úÖ [Matchmaking] Link v√°lido ap√≥s corre√ß√£o dos dados');
        } else {
          throw new Error('Dados do LoL n√£o correspondem ao link Discord');
        }
      }

      // VERIFICA√á√ÉO CR√çTICA: Verificar se o jogador est√° detectado pelo LCU
      const lcuData = requestData.lcuData;
      if (!lcuData || !lcuData.gameName || !lcuData.tagLine) {
        throw new Error('Jogador n√£o detectado pelo LCU. Certifique-se de estar logado no LoL');
      }

      // Verificar se os dados do LCU correspondem aos dados do Discord
      const lcuFullName = `${lcuData.gameName}#${lcuData.tagLine}`;
      const discordFullName = `${requestData.gameName}#${requestData.tagLine}`;
      
      console.log('üîç [Matchmaking] Comparando dados LCU vs Discord:', {
        lcuData: lcuData,
        lcuFullName: lcuFullName,
        discordData: {
          gameName: requestData.gameName,
          tagLine: requestData.tagLine
        },
        discordFullName: discordFullName,
        match: lcuFullName === discordFullName,
        lcuLength: lcuFullName.length,
        discordLength: discordFullName.length,
        lcuCharCodes: Array.from(lcuFullName).map(c => c.charCodeAt(0)),
        discordCharCodes: Array.from(discordFullName).map(c => c.charCodeAt(0))
      });
      
      // Se os dados n√£o batem exatamente, mas temos um link Discord v√°lido, usar os dados do Discord
      if (lcuFullName !== discordFullName) {
        console.log('‚ö†Ô∏è [Matchmaking] Dados do LCU e Discord n√£o batem, mas link Discord √© v√°lido. Usando dados do Discord.');
        // Continuar com os dados do Discord, j√° que o link foi validado
      }

      console.log('‚úÖ [Matchmaking] Jogador detectado pelo LCU e Discord:', lcuFullName);

      // Buscar jogador no banco usando o nome completo
      let player = await this.dbManager.getPlayerBySummonerName(discordFullName);
      if (!player) {
        // Se n√£o encontrou pelo nome completo, tentar pelo nome do link
        player = await this.dbManager.getPlayerBySummonerName(discordLink.summoner_name);
        if (!player) {
          throw new Error('Jogador n√£o encontrado no banco de dados');
        }
        // Atualizar o nome no banco para o formato completo
        await this.dbManager.updatePlayerSummonerName(player.id!, discordFullName);
        player.summoner_name = discordFullName;
        console.log('‚úÖ [Matchmaking] Nome do jogador atualizado para formato completo:', discordFullName);
      }

      // Verificar se j√° est√° na fila
      const existingPlayerIndex = this.queue.findIndex(p => p.id === player.id);
      if (existingPlayerIndex !== -1) {
        // Atualizar websocket se jogador reconectar
        this.queue[existingPlayerIndex].websocket = websocket;
        console.log('üîÑ [Matchmaking] Jogador j√° na fila via Discord, atualizando WebSocket:', discordFullName);
        websocket.send(JSON.stringify({
          type: 'queue_joined',
          data: { position: existingPlayerIndex + 1, estimated_wait: this.calculateEstimatedWaitTime() }
        }));
        return;
      }

      // Adicionar √† fila
      const queuedPlayer: QueuedPlayer = {
        id: player.id!,
        summonerName: discordFullName, // Usar nome completo
        region: player.region,
        currentMMR: player.custom_lp || 0,
        joinTime: new Date(),
        websocket: websocket,
        queuePosition: this.queue.length + 1,
        preferences: requestData.preferences || { primaryLane: 'fill', secondaryLane: 'fill' }
      };

      console.log('üîç [Matchmaking] Prefer√™ncias do jogador:', {
        receivedPreferences: requestData.preferences,
        finalPreferences: queuedPlayer.preferences,
        primaryLane: queuedPlayer.preferences?.primaryLane,
        secondaryLane: queuedPlayer.preferences?.secondaryLane
      });

      this.queue.push(queuedPlayer);

      // Persistir entrada na fila no banco
      await this.dbManager.addPlayerToQueue(
        queuedPlayer.id,
        queuedPlayer.summonerName, // Nome completo
        queuedPlayer.region,
        queuedPlayer.currentMMR,
        queuedPlayer.preferences
      );

      // Adicionar atividade
      const primaryLaneName = this.getLaneDisplayName(queuedPlayer.preferences?.primaryLane);
      this.addActivity(
        'player_joined',
        `${discordFullName} entrou na fila via Discord como ${primaryLaneName}`,
        discordFullName,
        undefined,
        queuedPlayer.preferences?.primaryLane
      );

      // Notificar jogador
      websocket.send(JSON.stringify({
        type: 'queue_joined',
        data: {
          position: this.queue.length,
          estimatedWait: this.calculateEstimatedWaitTime(),
          queueStatus: await this.getQueueStatus()
        }
      }));

      // Broadcast atualiza√ß√£o da fila
      await this.broadcastQueueUpdate();

      console.log(`‚úÖ [Matchmaking] ${discordFullName} entrou na fila via Discord (Posi√ß√£o: ${this.queue.length})`);

    } catch (error: any) {
      console.error('‚ùå [Matchmaking] Erro ao adicionar jogador √† fila via Discord:', error);
      websocket.send(JSON.stringify({
        type: 'error',
        message: 'Falha ao entrar na fila via Discord: ' + error.message
      }));
    }
  }

  // M√©todo para obter fila atual
  public getQueue(): QueuedPlayer[] {
    return [...this.queue];
  }

  // M√©todo para remover jogador da fila por ID ou nome
  public removePlayerFromQueueById(playerId?: number, summonerName?: string): boolean {
    console.log(`üîç [Matchmaking] Tentando remover jogador da fila:`, { playerId, summonerName });
    console.log(`üîç [Matchmaking] Fila atual:`, this.queue.map(p => ({ id: p.id, name: p.summonerName })));
    
    let playerIndex = -1;

    if (playerId) {
      playerIndex = this.queue.findIndex(p => p.id === playerId);
      console.log(`üîç [Matchmaking] Buscando por ID ${playerId}, encontrado no √≠ndice: ${playerIndex}`);
    } else if (summonerName) {
      // Buscar por nome exato primeiro
      playerIndex = this.queue.findIndex(p => p.summonerName === summonerName);
      console.log(`üîç [Matchmaking] Buscando por nome exato "${summonerName}", encontrado no √≠ndice: ${playerIndex}`);
      
      // Se n√£o encontrou por nome exato, tentar busca parcial (sem tagline)
      if (playerIndex === -1 && summonerName.includes('#')) {
        const gameNameOnly = summonerName.split('#')[0];
        playerIndex = this.queue.findIndex(p => p.summonerName.startsWith(gameNameOnly + '#'));
        console.log(`üîç [Matchmaking] Buscando por gameName "${gameNameOnly}", encontrado no √≠ndice: ${playerIndex}`);
      }
      
      // Se ainda n√£o encontrou, tentar busca por gameName apenas
      if (playerIndex === -1) {
        playerIndex = this.queue.findIndex(p => p.summonerName.split('#')[0] === summonerName);
        console.log(`üîç [Matchmaking] Buscando por gameName apenas "${summonerName}", encontrado no √≠ndice: ${playerIndex}`);
      }
    }

    if (playerIndex !== -1) {
      const player = this.queue[playerIndex];
      console.log(`‚úÖ [Matchmaking] Removendo jogador:`, { id: player.id, name: player.summonerName });
      
      this.queue.splice(playerIndex, 1);

      // Persistir sa√≠da da fila no banco
      this.dbManager.removePlayerFromQueue(player.id).then(() => {
        console.log(`‚úÖ [Matchmaking] Jogador ${player.summonerName} removido da fila persistente`);
      }).catch(error => {
        console.error('‚ùå [Matchmaking] Erro ao remover jogador da fila persistente:', error);
      });

      // Adicionar atividade
      this.addActivity(
        'player_left',
        `${player.summonerName} saiu da fila`,
        player.summonerName
      );

      // Atualizar posi√ß√µes na fila
      this.queue.forEach((p, index) => {
        p.queuePosition = index + 1;
      });

      // Broadcast atualiza√ß√£o da fila
      this.broadcastQueueUpdate();

      console.log(`‚ûñ [Matchmaking] ${player.summonerName} removido da fila. Nova fila:`, this.queue.map(p => ({ id: p.id, name: p.summonerName })));
      return true;
    } else {
      console.log(`‚ùå [Matchmaking] Jogador n√£o encontrado na fila:`, { playerId, summonerName });
      return false;
    }
  }

  // M√©todo para desligar o servi√ßo
  public shutdown(): void {
    this.isActive = false;
    
    if (this.matchmakingInterval) {
      clearInterval(this.matchmakingInterval);
      this.matchmakingInterval = null;
    }
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }

    // Limpar timeouts das partidas ativas
    this.activeMatches.forEach(match => {
      if (match.acceptTimeout) {
        clearTimeout(match.acceptTimeout);
      }
    });

    console.log('üõë Servi√ßo de matchmaking desligado');
  }

  // M√©todo para verificar se o servi√ßo est√° ativo
  public isServiceActive(): boolean {
    return this.isActive;
  }
}